/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, EventEmitter, forwardRef, HostListener, Inject, Input, Output, Renderer2 } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators, } from '@angular/forms';
import * as _moment from 'moment';
import { DL_DATE_TIME_DISPLAY_FORMAT, DL_DATE_TIME_INPUT_FORMATS, DlDateAdapter } from '../core';
import { DlDateTimeInputChange } from './dl-date-time-input-change';
/**
 * \@internal
 * @type {?}
 */
const moment = _moment;
/**
 * \@internal
 * @type {?}
 */
const alwaysTrueInputFilter = (/**
 * @return {?}
 */
() => true);
const ɵ0 = alwaysTrueInputFilter;
/**
 *  This directive allows the user to enter dates, using the keyboard, into an input box and
 *  angular will then store a date value in the model.
 *
 *  The input format(s), display format, and model format are independent and fully customizable.
 * @template D
 */
export class DlDateTimeInputDirective {
    /**
     * Constructs a new instance of this directive.
     * @param {?} _renderer
     *  reference to the renderer.
     * @param {?} _elementRef
     *  reference to this element.
     * @param {?} _dateAdapter
     *  date adapter for the date type in the model.
     * @param {?} _displayFormat
     *  from `DL_DATE_TIME_DISPLAY_FORMAT`, which defines the format to use for a valid date/time value.
     * @param {?} _inputFormats
     *  from `DL_DATE_TIME_INPUT_FORMATS`, which defines the input formats that allowed as valid date/time values.
     *  NB: moment is always in strict parse mode for this directive.
     */
    constructor(_renderer, _elementRef, _dateAdapter, _displayFormat, _inputFormats) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._dateAdapter = _dateAdapter;
        this._displayFormat = _displayFormat;
        this._inputFormats = _inputFormats;
        /* tslint:disable:member-ordering */
        this._filterValidator = (/**
         * @param {?} control
         * @return {?}
         */
        (control) => {
            return (this._inputFilter || alwaysTrueInputFilter)(this._value) ?
                null : { 'dlDateTimeInputFilter': { 'value': control.value } };
        });
        this._inputFilter = alwaysTrueInputFilter;
        this._isValid = true;
        this._parseValidator = (/**
         * @return {?}
         */
        () => {
            return this._isValid ?
                null : { 'dlDateTimeInputParse': { 'text': this._elementRef.nativeElement.value } };
        });
        this._changed = [];
        this._touched = [];
        this._validator = Validators.compose([this._parseValidator, this._filterValidator]);
        this._validatorOnChange = (/**
         * @return {?}
         */
        () => { });
        this._value = undefined;
        /**
         * Emits when a `change` event when date/time is selected or
         * the value of the date/time picker changes.
         *
         */
        this.dateChange = new EventEmitter();
    }
    /**
     * Set a function used to determine whether or not the `value` entered by the user is allowed.
     * @param {?} inputFilterFunction
     *   a function that returns `true` if the `value` entered by the user is allowed, otherwise `false`.
     * @return {?}
     */
    set dlDateTimeInputFilter(inputFilterFunction) {
        this._inputFilter = inputFilterFunction;
        this._validatorOnChange();
    }
    /* tslint:enable:member-ordering */
    /**
     * Returns `D` value of the date/time input or `undefined` | `null` if no value is set.
     *
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Emit a `change` event when the value of the input changes.
     * @return {?}
     */
    _onChange() {
        this.dateChange.emit(new DlDateTimeInputChange(this._value));
    }
    /**
     * Format the input text using {\@link DL_DATE_TIME_DISPLAY_FORMAT} and mark the control as touched.
     * @return {?}
     */
    _onBlur() {
        if (this._value) {
            this.writeValue(this._value);
        }
        this._touched.forEach((/**
         * @param {?} onTouched
         * @return {?}
         */
        onTouched => onTouched()));
    }
    /**
     * Parse the user input into a possibly valid date.
     * The model value is not set if the input is NOT one of the {\@link DL_DATE_TIME_INPUT_FORMATS}.
     * @param {?} value
     *   Value of the input control.
     * @return {?}
     */
    _onInput(value) {
        /** @type {?} */
        const testDate = value === null || value === undefined || value === ''
            ? undefined
            : moment(value, this._inputFormats, true);
        this._isValid = testDate && testDate.isValid();
        this._value = this._isValid ? this._dateAdapter.fromMilliseconds(testDate.valueOf()) : undefined;
        this._changed.forEach((/**
         * @param {?} onChanged
         * @return {?}
         */
        onChanged => onChanged(this._value)));
    }
    /**
     * \@internal
     * @param {?} onChange
     * @return {?}
     */
    registerOnChange(onChange) {
        this._changed.push(onChange);
    }
    /**
     * \@internal
     * @param {?} onTouched
     * @return {?}
     */
    registerOnTouched(onTouched) {
        this._touched.push(onTouched);
    }
    /**
     * \@internal
     * @param {?} validatorOnChange
     * @return {?}
     */
    registerOnValidatorChange(validatorOnChange) {
        this._validatorOnChange = validatorOnChange;
    }
    /**
     * \@internal
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    /**
     * \@internal
     * @param {?} control
     * @return {?}
     */
    validate(control) {
        return this._validator(control);
    }
    /**
     * \@internal
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        /** @type {?} */
        const normalizedValue = value === null || value === undefined
            ? ''
            : moment(value).format(this._displayFormat);
        this._renderer.setProperty(this._elementRef.nativeElement, 'value', normalizedValue);
    }
}
DlDateTimeInputDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[dlDateTimeInput]',
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => DlDateTimeInputDirective)), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => DlDateTimeInputDirective)), multi: true }
                ]
            },] }
];
/** @nocollapse */
DlDateTimeInputDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: DlDateAdapter },
    { type: String, decorators: [{ type: Inject, args: [DL_DATE_TIME_DISPLAY_FORMAT,] }] },
    { type: Array, decorators: [{ type: Inject, args: [DL_DATE_TIME_INPUT_FORMATS,] }] }
];
DlDateTimeInputDirective.propDecorators = {
    dateChange: [{ type: Output }],
    dlDateTimeInputFilter: [{ type: Input }],
    _onChange: [{ type: HostListener, args: ['change',] }],
    _onBlur: [{ type: HostListener, args: ['blur',] }],
    _onInput: [{ type: HostListener, args: ['input', ['$event.target.value'],] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._filterValidator;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._inputFilter;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._isValid;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._parseValidator;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._changed;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._touched;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._validator;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._validatorOnChange;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._value;
    /**
     * Emits when a `change` event when date/time is selected or
     * the value of the date/time picker changes.
     *
     * @type {?}
     */
    DlDateTimeInputDirective.prototype.dateChange;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._dateAdapter;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._displayFormat;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._inputFormats;
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGwtZGF0ZS10aW1lLWlucHV0LmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLyIsInNvdXJjZXMiOlsiZGwtZGF0ZS10aW1lLWlucHV0L2RsLWRhdGUtdGltZS1pbnB1dC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUM5SCxPQUFPLEVBR0wsYUFBYSxFQUNiLGlCQUFpQixFQUlqQixVQUFVLEdBQ1gsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEtBQUssT0FBTyxNQUFNLFFBQVEsQ0FBQztBQUNsQyxPQUFPLEVBQUMsMkJBQTJCLEVBQUUsMEJBQTBCLEVBQUUsYUFBYSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBQy9GLE9BQU8sRUFBQyxxQkFBcUIsRUFBQyxNQUFNLDZCQUE2QixDQUFDOzs7OztNQUs1RCxNQUFNLEdBQUcsT0FBTzs7Ozs7TUFLaEIscUJBQXFCOzs7QUFBNEIsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFBOzs7Ozs7Ozs7QUFlakUsTUFBTSxPQUFPLHdCQUF3Qjs7Ozs7Ozs7Ozs7Ozs7O0lBd0NuQyxZQUNVLFNBQW9CLEVBQ3BCLFdBQXVCLEVBQ3ZCLFlBQThCLEVBQ2dCLGNBQXNCLEVBQ3ZCLGFBQXVCO1FBSnBFLGNBQVMsR0FBVCxTQUFTLENBQVc7UUFDcEIsZ0JBQVcsR0FBWCxXQUFXLENBQVk7UUFDdkIsaUJBQVksR0FBWixZQUFZLENBQWtCO1FBQ2dCLG1CQUFjLEdBQWQsY0FBYyxDQUFRO1FBQ3ZCLGtCQUFhLEdBQWIsYUFBYSxDQUFVOztRQTFDdEUscUJBQWdCOzs7O1FBQWdCLENBQUMsT0FBd0IsRUFBMkIsRUFBRTtZ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L0Y7YUFDRjs7OztZQXJDNkYsU0FBUztZQUFwRixVQUFVO1lBWW9DLGFBQWE7eUNBc0V6RSxNQUFNLFNBQUMsMkJBQTJCO3dDQUNsQyxNQUFNLFNBQUMsMEJBQTBCOzs7eUJBdEJuQyxNQUFNO29DQThCTixLQUFLO3dCQWtCTCxZQUFZLFNBQUMsUUFBUTtzQkFPckIsWUFBWSxTQUFDLE1BQU07dUJBYW5CLFlBQVksU0FBQyxPQUFPLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQzs7Ozs7OztJQXhGOUMsb0RBR0M7Ozs7O0lBQ0QsZ0RBQTZFOzs7OztJQUM3RSw0Q0FBd0I7Ozs7O0lBQ3hCLG1EQUdDOzs7OztJQUNELDRDQUE4Qzs7Ozs7SUFDOUMsNENBQXNDOzs7OztJQUN0Qyw4Q0FBdUY7Ozs7O0lBQ3ZGLHNEQUFrRDs7Ozs7SUFDbEQsMENBQTBDOzs7Ozs7O0lBTTFDLDhDQUNtRTs7Ozs7SUFpQmpFLDZDQUE0Qjs7Ozs7SUFDNUIsK0NBQStCOzs7OztJQUMvQixnREFBc0M7Ozs7O0lBQ3RDLGtEQUE0RTs7Ozs7SUFDNUUsaURBQTRFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSG9zdExpc3RlbmVyLCBJbmplY3QsIElucHV0LCBPdXRwdXQsIFJlbmRlcmVyMn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBBYnN0cmFjdENvbnRyb2wsXG4gIENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICBOR19WQUxJREFUT1JTLFxuICBOR19WQUxVRV9BQ0NFU1NPUixcbiAgVmFsaWRhdGlvbkVycm9ycyxcbiAgVmFsaWRhdG9yLFxuICBWYWxpZGF0b3JGbixcbiAgVmFsaWRhdG9ycyxcbn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0ICogYXMgX21vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHtETF9EQVRFX1RJTUVfRElTUExBWV9GT1JNQVQsIERMX0RBVEVfVElNRV9JTlBVVF9GT1JNQVRTLCBEbERhdGVBZGFwdGVyfSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7RGxEYXRlVGltZUlucHV0Q2hhbmdlfSBmcm9tICcuL2RsLWRhdGUtdGltZS1pbnB1dC1jaGFuZ2UnO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBtb21lbnQgPSBfbW9tZW50O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBhbHdheXNUcnVlSW5wdXRGaWx0ZXI6ICh2YWx1ZTogYW55KSA9PiBib29sZWFuID0gKCkgPT4gdHJ1ZTtcblxuLyoqXG4gKiAgVGhpcyBkaXJlY3RpdmUgYWxsb3dzIHRoZSB1c2VyIHRvIGVudGVyIGRhdGVzLCB1c2luZyB0aGUga2V5Ym9hcmQsIGludG8gYW4gaW5wdXQgYm94IGFuZFxuICogIGFuZ3VsYXIgd2lsbCB0aGVuIHN0b3JlIGEgZGF0ZSB2YWx1ZSBpbiB0aGUgbW9kZWwuXG4gKlxuICogIFRoZSBpbnB1dCBmb3JtYXQocyksIGRpc3BsYXkgZm9ybWF0LCBhbmQgbW9kZWwgZm9ybWF0IGFyZSBpbmRlcGVuZGVudCBhbmQgZnVsbHkgY3VzdG9taXphYmxlLlxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdpbnB1dFtkbERhdGVUaW1lSW5wdXRdJyxcbiAgcHJvdmlkZXJzOiBbXG4gICAge3Byb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEbERhdGVUaW1lSW5wdXREaXJlY3RpdmUpLCBtdWx0aTogdHJ1ZX0sXG4gICAge3Byb3ZpZGU6IE5HX1ZBTElEQVRPUlMsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERsRGF0ZVRpbWVJbnB1dERpcmVjdGl2ZSksIG11bHRpOiB0cnVlfVxuICBdXG59KVxuZXhwb3J0IGNsYXNzIERsRGF0ZVRpbWVJbnB1dERpcmVjdGl2ZTxEPiBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0b3Ige1xuXG4gIC8qIHRzbGludDpkaXNhYmxlOm1lbWJlci1vcmRlcmluZyAqL1xuICBwcml2YXRlIF9maWx0ZXJWYWxpZGF0b3I6IFZhbGlkYXRvckZuID0gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICByZXR1cm4gKHRoaXMuX2lucHV0RmlsdGVyIHx8IGFsd2F5c1RydWVJbnB1dEZpbHRlcikodGhpcy5fdmFsdWUpID9cbiAgICAgIG51bGwgOiB7J2RsRGF0ZVRpbWVJbnB1dEZpbHRlcic6IHsndmFsdWUnOiBjb250cm9sLnZhbHVlfX07XG4gIH1cbiAgcHJpdmF0ZSBfaW5wdXRGaWx0ZXI6ICh2YWx1ZTogKEQgfCBudWxsKSkgPT4gYm9vbGVhbiA9IGFsd2F5c1RydWVJbnB1dEZpbHRlcjtcbiAgcHJpdmF0ZSBfaXNWYWxpZCA9IHRydWU7XG4gIHByaXZhdGUgX3BhcnNlVmFsaWRhdG9yOiBWYWxpZGF0b3JGbiA9ICgpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQgP1xuICAgICAgbnVsbCA6IHsnZGxEYXRlVGltZUlucHV0UGFyc2UnOiB7J3RleHQnOiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWV9fTtcbiAgfVxuICBwcml2YXRlIF9jaGFuZ2VkOiAoKHZhbHVlOiBEKSA9PiB2b2lkKVtdID0gW107XG4gIHByaXZhdGUgX3RvdWNoZWQ6ICgoKSA9PiB2b2lkKVtdID0gW107XG4gIHByaXZhdGUgX3ZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZShbdGhpcy5fcGFyc2VWYWxpZGF0b3IsIHRoaXMuX2ZpbHRlclZhbGlkYXRvcl0pO1xuICBwcml2YXRlIF92YWxpZGF0b3JPbkNoYW5nZTogKCkgPT4gdm9pZCA9ICgpID0+IHt9O1xuICBwcml2YXRlIF92YWx1ZTogRCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogRW1pdHMgd2hlbiBhIGBjaGFuZ2VgIGV2ZW50IHdoZW4gZGF0ZS90aW1lIGlzIHNlbGVjdGVkIG9yXG4gICAqIHRoZSB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlciBjaGFuZ2VzLlxuICAgKiovXG4gIEBPdXRwdXQoKVxuICByZWFkb25seSBkYXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxEbERhdGVUaW1lSW5wdXRDaGFuZ2U8RD4+KCk7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhpcyBkaXJlY3RpdmUuXG4gICAqIEBwYXJhbSBfcmVuZGVyZXJcbiAgICogIHJlZmVyZW5jZSB0byB0aGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSBfZWxlbWVudFJlZlxuICAgKiAgcmVmZXJlbmNlIHRvIHRoaXMgZWxlbWVudC5cbiAgICogQHBhcmFtIF9kYXRlQWRhcHRlclxuICAgKiAgZGF0ZSBhZGFwdGVyIGZvciB0aGUgZGF0ZSB0eXBlIGluIHRoZSBtb2RlbC5cbiAgICogQHBhcmFtIF9kaXNwbGF5Rm9ybWF0XG4gICAqICBmcm9tIGBETF9EQVRFX1RJTUVfRElTUExBWV9GT1JNQVRgLCB3aGljaCBkZWZpbmVzIHRoZSBmb3JtYXQgdG8gdXNlIGZvciBhIHZhbGlkIGRhdGUvdGltZSB2YWx1ZS5cbiAgICogQHBhcmFtIF9pbnB1dEZvcm1hdHNcbiAgICogIGZyb20gYERMX0RBVEVfVElNRV9JTlBVVF9GT1JNQVRTYCwgd2hpY2ggZGVmaW5lcyB0aGUgaW5wdXQgZm9ybWF0cyB0aGF0IGFsbG93ZWQgYXMgdmFsaWQgZGF0ZS90aW1lIHZhbHVlcy5cbiAgICogIE5COiBtb21lbnQgaXMgYWx3YXlzIGluIHN0cmljdCBwYXJzZSBtb2RlIGZvciB0aGlzIGRpcmVjdGl2ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIF9kYXRlQWRhcHRlcjogRGxEYXRlQWRhcHRlcjxEPixcbiAgICBASW5qZWN0KERMX0RBVEVfVElNRV9ESVNQTEFZX0ZPUk1BVCkgcHJpdmF0ZSByZWFkb25seSBfZGlzcGxheUZvcm1hdDogc3RyaW5nLFxuICAgIEBJbmplY3QoRExfREFURV9USU1FX0lOUFVUX0ZPUk1BVFMpIHByaXZhdGUgcmVhZG9ubHkgX2lucHV0Rm9ybWF0czogc3RyaW5nW11cbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBTZXQgYSBmdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0aGUgYHZhbHVlYCBlbnRlcmVkIGJ5IHRoZSB1c2VyIGlzIGFsbG93ZWQuXG4gICAqIEBwYXJhbSBpbnB1dEZpbHRlckZ1bmN0aW9uXG4gICAqICAgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGVudGVyZWQgYnkgdGhlIHVzZXIgaXMgYWxsb3dlZCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgZGxEYXRlVGltZUlucHV0RmlsdGVyKGlucHV0RmlsdGVyRnVuY3Rpb246ICh2YWx1ZTogRCB8IG51bGwpID0+IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9pbnB1dEZpbHRlciA9IGlucHV0RmlsdGVyRnVuY3Rpb247XG4gICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UoKTtcbiAgfVxuXG4gIC8qIHRzbGludDplbmFibGU6bWVtYmVyLW9yZGVyaW5nICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYERgIHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgaW5wdXQgb3IgYHVuZGVmaW5lZGAgfCBgbnVsbGAgaWYgbm8gdmFsdWUgaXMgc2V0LlxuICAgKiovXG4gIGdldCB2YWx1ZSgpOiBEIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCBhIGBjaGFuZ2VgIGV2ZW50IHdoZW4gdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBjaGFuZ2VzLlxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcignY2hhbmdlJykgX29uQ2hhbmdlKCkge1xuICAgIHRoaXMuZGF0ZUNoYW5nZS5lbWl0KG5ldyBEbERhdGVUaW1lSW5wdXRDaGFuZ2UodGhpcy5fdmFsdWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtYXQgdGhlIGlucHV0IHRleHQgdXNpbmcge0BsaW5rIERMX0RBVEVfVElNRV9ESVNQTEFZX0ZPUk1BVH0gYW5kIG1hcmsgdGhlIGNvbnRyb2wgYXMgdG91Y2hlZC5cbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2JsdXInKSBfb25CbHVyKCkge1xuICAgIGlmICh0aGlzLl92YWx1ZSkge1xuICAgICAgdGhpcy53cml0ZVZhbHVlKHRoaXMuX3ZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5fdG91Y2hlZC5mb3JFYWNoKG9uVG91Y2hlZCA9PiBvblRvdWNoZWQoKSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgdGhlIHVzZXIgaW5wdXQgaW50byBhIHBvc3NpYmx5IHZhbGlkIGRhdGUuXG4gICAqIFRoZSBtb2RlbCB2YWx1ZSBpcyBub3Qgc2V0IGlmIHRoZSBpbnB1dCBpcyBOT1Qgb25lIG9mIHRoZSB7QGxpbmsgRExfREFURV9USU1FX0lOUFVUX0ZPUk1BVFN9LlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogICBWYWx1ZSBvZiB0aGUgaW5wdXQgY29udHJvbC5cbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2lucHV0JywgWyckZXZlbnQudGFyZ2V0LnZhbHVlJ10pIF9vbklucHV0KHZhbHVlOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgY29uc3QgdGVzdERhdGUgPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJ1xuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogbW9tZW50KHZhbHVlLCB0aGlzLl9pbnB1dEZvcm1hdHMsIHRydWUpO1xuXG4gICAgdGhpcy5faXNWYWxpZCA9IHRlc3REYXRlICYmIHRlc3REYXRlLmlzVmFsaWQoKTtcbiAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX2lzVmFsaWQgPyB0aGlzLl9kYXRlQWRhcHRlci5mcm9tTWlsbGlzZWNvbmRzKHRlc3REYXRlLnZhbHVlT2YoKSkgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2hhbmdlZC5mb3JFYWNoKG9uQ2hhbmdlZCA9PiBvbkNoYW5nZWQodGhpcy5fdmFsdWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlZ2lzdGVyT25DaGFuZ2Uob25DaGFuZ2U6ICh2YWx1ZTogYW55KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fY2hhbmdlZC5wdXNoKG9uQ2hhbmdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKG9uVG91Y2hlZDogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuX3RvdWNoZWQucHVzaChvblRvdWNoZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSh2YWxpZGF0b3JPbkNoYW5nZTogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuX3ZhbGlkYXRvck9uQ2hhbmdlID0gdmFsaWRhdG9yT25DaGFuZ2U7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl92YWxpZGF0b3IoY29udHJvbCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICB3cml0ZVZhbHVlKHZhbHVlOiBEKTogdm9pZCB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgPyAnJ1xuICAgICAgOiBtb21lbnQodmFsdWUpLmZvcm1hdCh0aGlzLl9kaXNwbGF5Rm9ybWF0KTtcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5vcm1hbGl6ZWRWYWx1ZSk7XG4gIH1cbn1cbiJdfQ==