/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright 2013-present Dale Lotts All Rights Reserved.
 * http://www.dalelotts.com
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
 */
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, NgZone, Output } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import * as _moment from 'moment';
import { take } from 'rxjs/operators';
import { DlDateAdapter } from '../core';
import { DlDateTimePickerChange } from './dl-date-time-picker-change';
import { DlDayModelProvider } from './dl-model-provider-day';
import { DlHourModelProvider } from './dl-model-provider-hour';
import { DlMinuteModelProvider } from './dl-model-provider-minute';
import { DlMonthModelProvider } from './dl-model-provider-month';
import { DlYearModelProvider } from './dl-model-provider-year';
/**
 * Work around for moment namespace conflict when used with webpack and rollup.
 * See https://github.com/dherges/ng-packagr/issues/163
 *
 * Depending on whether rollup is used, moment needs to be imported differently.
 * Since Moment.js doesn't have a default export, we normally need to import using
 * the `* as`syntax.
 *
 * rollup creates a synthetic default module and we thus need to import it using
 * the `default as` syntax.
 *
 * \@internal
 *
 * @type {?}
 */
const moment = _moment;
/**
 * Maps key codes to the model provider function name
 * that should be called to perform the action.
 *
 * \@internal
 *
 * @type {?}
 */
const keyCodeToModelProviderMethod = {
    'ArrowDown': 'goDown',
    'ArrowLeft': 'goLeft',
    'ArrowRight': 'goRight',
    'ArrowUp': 'goUp',
    'Down': 'goDown',
    'End': 'goEnd',
    'Home': 'goHome',
    'Left': 'goLeft',
    'PageDown': 'pageDown',
    'PageUp': 'pageUp',
    'Right': 'goRight',
    'Up': 'goUp',
    33: 'pageUp',
    34: 'pageDown',
    35: 'goEnd',
    36: 'goHome',
    37: 'goLeft',
    38: 'goUp',
    39: 'goRight',
    40: 'goDown',
};
/**
 * List of view names for the calendar.
 *
 * This list must be in order from
 * smallest increment of time to largest increment of time.
 *
 * \@internal
 *
 * @type {?}
 */
const VIEWS = [
    'minute',
    'hour',
    'day',
    'month',
    'year'
];
/**
 * Component that provides all of the user facing functionality of the date/time picker.
 * @template D
 */
export class DlDateTimePickerComponent {
    /**
     * Used to construct a new instance of a date/time picker.
     *
     * @param {?} _elementRef
     *  reference to this element.
     * @param {?} _ngZone
     *  reference to an NgZone instance used to select the active element outside of angular.
     * @param {?} _dateAdapter
     *  date adapter for the date type in the model.
     * @param {?} yearModelComponent
     *  provider for the year view model.
     * @param {?} monthModelComponent
     *  provider for the month view model.
     * @param {?} dayModelComponent
     *  provider for the day view model.
     * @param {?} hourModelComponent
     *  provider for the hour view model.
     * @param {?} minuteModelComponent
     *  provider for the minute view model.
     */
    constructor(_elementRef, _ngZone, _dateAdapter, yearModelComponent, monthModelComponent, dayModelComponent, hourModelComponent, minuteModelComponent) {
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        this._dateAdapter = _dateAdapter;
        this.yearModelComponent = yearModelComponent;
        this.monthModelComponent = monthModelComponent;
        this.dayModelComponent = dayModelComponent;
        this.hourModelComponent = hourModelComponent;
        this.minuteModelComponent = minuteModelComponent;
        /**
         * Change listener callback functions registered
         * via `registerOnChange`
         * \@internal
         *
         */
        this._changed = [];
        /**
         * Maps view name to the next view (the view for the next smallest increment of time).
         * \@internal
         *
         */
        this._nextView = {
            'year': 'month',
            'month': 'day',
            'day': 'hour',
            'hour': 'minute'
        };
        /**
         * Maps view name to the previous view (the view for the next largest increment of time).
         * \@internal
         *
         */
        this._previousView = {
            'minute': 'hour',
            'hour': 'day',
            'day': 'month',
            'month': 'year'
        };
        /**
         * Touch listener callback functions registered
         * via `registerOnChange`
         * \@internal
         *
         */
        this._touched = [];
        /**
         * Emits when a `change` event when date/time is selected or
         * the value of the date/time picker changes.
         *
         */
        this.change = new EventEmitter();
        /**
         * Specifies the classes used to display the left icon.
         *
         * This component uses OPENICONIC https://useiconic.com/open
         * by default but any icon library may be used.
         */
        this.leftIconClass = [
            'oi',
            'oi-chevron-left'
        ];
        /**
         * The highest view that the date/time picker can show.
         * Setting this to a view less than year could make it more
         * difficult for the end-user to navigate to certain dates.
         */
        this.maxView = 'year';
        /**
         * The view that will be used for date/time selection.
         *
         * The default of `minute  means that selection will not happen
         * until the end-user clicks on a cell in the minute view.
         *
         * for example, if you want the end-user to select a only day (date),
         * setting `minView` to `day` will cause selection to happen when the
         * end-user selects a cell in the day view.
         *
         * NOTE: This must be set lower than or equal to `startView'
         */
        this.minView = 'minute';
        /**
         * The number of minutes between each `.dl-abdtp-minute` button.
         *
         * Must be greater than `0` and less than `60`.
         */
        this.minuteStep = 5;
        /**
         * Specifies the classes used to display the right icon.
         *
         * This component uses OPENICONIC https://useiconic.com/open
         * by default but any icon library may be used.
         */
        this.rightIconClass = [
            'oi',
            'oi-chevron-right'
        ];
        /* tslint:disable:member-ordering */
        /**
         *  Determine whether or not the `DateButton` is selectable by the end user.
         */
        this.selectFilter = (/**
         * @return {?}
         */
        () => true);
        /**
         * The initial view that the date/time picker will show.
         * The picker will also return to this view after a date/time
         * is selected.
         *
         * NOTE: This must be set lower than or equal to `maxView'
         */
        this.startView = 'day';
        /**
         * Specifies the classes used to display the up icon.
         *
         * This component uses OPENICONIC https://useiconic.com/open
         * by default but any icon library may be used.
         */
        this.upIconClass = [
            'oi',
            'oi-chevron-top'
        ];
        this._viewToModelProvider = {
            year: yearModelComponent,
            month: monthModelComponent,
            day: dayModelComponent,
            hour: hourModelComponent,
            minute: minuteModelComponent,
        };
    }
    /* tslint:enable:member-ordering */
    /**
     * Set's the model for the current view after applying the selection filter.
     *
     * \@internal
     *
     * @private
     * @param {?} model
     * @return {?}
     */
    set model(model) {
        this._model = this.applySelectFilter(model);
    }
    /**
     * Returns `D` value of the date/time picker or undefined/null if no value is set.
     *
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Sets value of the date/time picker and emits a change event if the
     * new value is different from the previous value.
     *
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (this._value !== value) {
            this._value = value;
            this.model = this._viewToModelProvider[this._model.viewName].getModel(this.getStartDate(), this.valueOf);
            this._changed.forEach((/**
             * @param {?} f
             * @return {?}
             */
            f => f(value)));
            this.change.emit(new DlDateTimePickerChange(value));
        }
    }
    /**
     * Returns `milliseconds` value of the date/time picker or undefined/null if no value is set.
     *
     * @return {?}
     */
    get valueOf() {
        return this._dateAdapter.toMilliseconds(this._value);
    }
    /**
     * Applies the `selectionFilter` by adding the `dl-abdtp-disabled`
     * class to any `DateButton` where `selectFilter` returned false.
     *
     * \@internal
     * @private
     * @param {?} model
     *  the new model
     *
     * @return {?}
     *  the supplied model with zero or more `DateButton`'s
     *  having the `dl-abdtp-disabled` class set to `true` if the
     *  selection for that date should be disabled.
     *
     */
    applySelectFilter(model) {
        if (this.selectFilter) {
            model.rows = model.rows.map((/**
             * @param {?} row
             * @return {?}
             */
            (row) => {
                row.cells.map((/**
                 * @param {?} dateButton
                 * @return {?}
                 */
                (dateButton) => {
                    /** @type {?} */
                    const disabled = !this.selectFilter(dateButton, model.viewName);
                    dateButton.classes['dl-abdtp-disabled'] = disabled;
                    if (disabled) {
                        dateButton.classes['aria-disabled'] = true;
                    }
                    return dateButton;
                }));
                return row;
            }));
        }
        return model;
    }
    /**
     * Focuses the `.dl-abdtp-active` cell after the microtask queue is empty.
     * \@internal
     *
     * @private
     * @return {?}
     */
    focusActiveCell() {
        this._ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe((/**
             * @return {?}
             */
            () => {
                this._elementRef.nativeElement.querySelector('.dl-abdtp-active').focus();
            }));
        }));
    }
    /**
     * Determines the start date for the picker.
     * \@internal
     *
     * @private
     * @return {?}
     */
    getStartDate() {
        if (hasValue(this._value)) {
            return this._dateAdapter.toMilliseconds(this._value);
        }
        if (hasValue(this.startDate)) {
            return this.startDate;
        }
        return moment().valueOf();
    }
    /**
     * Determine the start view for the picker
     * @private
     * @return {?}
     *  the largest time increment view between the `minView` or `minute` view and the `startView` or `day` view.
     */
    getStartView() {
        /** @type {?} */
        const startIndex = Math.max(VIEWS.indexOf(this.minView || 'minute'), VIEWS.indexOf(this.startView || 'day'));
        return VIEWS[startIndex];
    }
    /**
     * Calls all registered `touch` callback functions.
     * \@internal
     *
     * @private
     * @return {?}
     */
    onTouch() {
        this._touched.forEach((/**
         * @param {?} onTouched
         * @return {?}
         */
        (onTouched) => onTouched()));
    }
    /**
     * Receives configuration changes detected by Angular and passes the changes on
     * to the model providers so the provider is aware of any necessary configuration
     * changes (i.e. minuteStep)
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    ngOnChanges(changes) {
        Object.keys(this._viewToModelProvider)
            .map((/**
         * @param {?} key
         * @return {?}
         */
        (key) => this._viewToModelProvider[key]))
            .forEach((/**
         * @param {?} provider
         * @return {?}
         */
        (provider) => provider.onChanges(changes)));
        if (this._model) { // only update the model after ngOnInit has set it the first time.
            this.model = this._viewToModelProvider[this._model.viewName].getModel(this._model.activeDate, this.valueOf);
        }
    }
    /**
     * Sets the initial model.
     *
     * \@internal
     *
     * @return {?}
     */
    ngOnInit() {
        this.model = this._viewToModelProvider[this.getStartView()].getModel(this.getStartDate(), this.valueOf);
    }
    /**
     * Handles click (and enter & space key down) events on the date elements.
     *
     * If the current view is the minimum view then the date value is selected
     * and the picker returns to the start view.
     *
     * Otherwise the picker displays the next view with the next
     * smallest time increment.
     *
     * \@internal
     *
     * @param {?} dateButton
     * @return {?}
     */
    _onDateClick(dateButton) {
        if (dateButton.classes['dl-abdtp-disabled']) {
            return;
        }
        /** @type {?} */
        let nextView = this._nextView[this._model.viewName];
        if ((this.minView || 'minute') === this._model.viewName) {
            this.value = this._dateAdapter.fromMilliseconds(dateButton.value);
            nextView = this.startView;
        }
        this.model = this._viewToModelProvider[nextView].getModel(dateButton.value, this.valueOf);
        this.onTouch();
    }
    /**
     * Handles click (and enter & space key down) events on the left button.
     *
     * Changes the displayed time range of the picker to the previous time range.
     * For example, in year view, the previous decade is displayed.
     *
     * \@internal
     *
     * @return {?}
     */
    _onLeftClick() {
        this.model = this._viewToModelProvider[this._model.viewName].getModel(this._model.leftButton.value, this.valueOf);
        this.onTouch();
    }
    /**
     * Handles click (and enter & space key down) events on the up button.
     *
     * Changes the view of the picker to the next largest time increment.
     * For example, in day view, the next view displayed will be month view.
     *
     * \@internal
     *
     * @return {?}
     */
    _onUpClick() {
        this.model = this._viewToModelProvider[this._previousView[this._model.viewName]].getModel(this._model.upButton.value, this.valueOf);
    }
    /**
     * Handles click (and enter & space key down) events on the right button.
     *
     * Changes the displayed time range of the picker to the next time range.
     * For example, in year view, the next decade is displayed.
     *
     * \@internal
     *
     * @return {?}
     */
    _onRightClick() {
        this.model = this._viewToModelProvider[this._model.viewName].getModel(this._model.rightButton.value, this.valueOf);
        this.onTouch();
    }
    /**
     * Handles various key down events to move the `active date` around the calendar.
     *
     * \@internal
     *
     * @param {?} $event
     * @return {?}
     */
    _handleKeyDown($event) {
        /** @type {?} */
        const functionName = keyCodeToModelProviderMethod[$event.key];
        console.log($event, functionName);
        if (functionName) {
            /** @type {?} */
            const modelProvider = this._viewToModelProvider[this._model.viewName];
            this.model = modelProvider[functionName](this._model.activeDate, this.valueOf);
            this.focusActiveCell();
            // Prevent unexpected default actions such as form submission.
            $event.preventDefault();
        }
    }
    /**
     * Implements ControlValueAccessor.registerOnChange to register change listeners.
     * \@internal
     *
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._changed.push(fn);
    }
    /**
     * Implements ControlValueAccessor.registerOnTouched to register touch listeners.
     * \@internal
     *
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._touched.push(fn);
    }
    /**
     * Implements ControlValueAccessor.writeValue to store the value from the model.
     * \@internal
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
}
DlDateTimePickerComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: DlDateTimePickerComponent,
                        multi: true
                    }
                ],
                selector: 'dl-date-time-picker',
                template: "<div class=\"text-center dl-abdtp-{{_model.viewName}}-view \">\n  <div class=\"row align-items-center no-gutters\">\n    <button class=\"col dl-abdtp-left-button align-items-center\"\n            type=\"button\"\n            [attr.aria-label]=\"_model.leftButton.ariaLabel\"\n            [attr.title]=\"_model.leftButton.ariaLabel\"\n            [ngClass]=\"_model.leftButton.classes\"\n            (click)=\"_onLeftClick()\">\n      <span class=\"left-icon\" [ngClass]=\"leftIconClass\"></span>\n    </button>\n\n    <div *ngIf=\"_model.viewName === (this.maxView || 'year'); then maxViewLabel else defaultViewLabel;\"></div>\n\n    <button class=\"col dl-abdtp-right-button\"\n            type=\"button\"\n            [attr.aria-label]=\"_model.rightButton.ariaLabel\"\n            [attr.title]=\"_model.rightButton.ariaLabel\"\n            (click)=\"_onRightClick()\"\n            [ngClass]=\"_model.rightButton.classes\">\n      <span class=\"right-icon\" [ngClass]=\"rightIconClass\"></span>\n    </button>\n  </div>\n  <div (keydown)=\"_handleKeyDown($event)\">\n    <div *ngIf=\"_model.rowLabels?.length\" class=\"row no-gutters\">\n      <div *ngFor=\"let label of _model.rowLabels\" class=\"col align-items-center no-gutters dl-abdtp-col-label\">{{label}}</div>\n    </div>\n    <div *ngFor=\"let row of _model.rows\" class=\"row align-items-center no-gutters\">\n      <div *ngFor=\"let cell of row.cells\"\n           role=\"gridcell\"\n           class=\"col dl-abdtp-date-button dl-abdtp-{{_model.viewName}} {{cell.value}}\"\n           [ngClass]=\"cell.classes\"\n           [attr.aria-label]=\"cell.ariaLabel\"\n           [attr.aria-disabled]=\"cell.classes['dl-abdtp-disabled']\"\n           [attr.tabindex]=\"cell.classes['dl-abdtp-active'] ? 0 : -1\"\n           (click)=\"_onDateClick(cell)\"\n           (keydown.space)=\"_onDateClick(cell)\"\n           (keydown.enter)=\"_onDateClick(cell)\"\n      >{{cell.display}}</div>\n    </div>\n  </div>\n</div>\n\n<ng-template #maxViewLabel>\n  <div class=\"col-10 dl-abdtp-view-label\">{{_model.viewLabel}}</div>\n</ng-template>\n<ng-template #defaultViewLabel>\n  <button class=\"col-10 dl-abdtp-view-label dl-abdtp-up-button\"\n          type=\"button\"\n          [attr.aria-label]=\"_model.upButton.ariaLabel\"\n          [attr.title]=\"_model.upButton.ariaLabel\"\n          (click)=\"_onUpClick()\"\n          [ngClass]=\"_model.upButton.classes\"\n  >{{_model.viewLabel}}&nbsp;<span class=\"up-icon\" [ngClass]=\"upIconClass\"></span>\n  </button>\n</ng-template>\n",
                styles: [":host{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.dl-abdtp-col-label,.dl-abdtp-view-label{font-weight:700}.dl-abdtp-date-button,.dl-abdtp-left-button,.dl-abdtp-right-button,.dl-abdtp-view-label{padding:5px;border-radius:999px;cursor:pointer;color:rgba(0,0,0,.87);outline:0}.dl-abdtp-date-button,.dl-abdtp-left-button,.dl-abdtp-right-button,.dl-abdtp-up-button{border-width:0}.dl-abdtp-active:focus,.dl-abdtp-date-button:focus,.dl-abdtp-date-button:hover,.dl-abdtp-left-button:focus,.dl-abdtp-left-button:hover,.dl-abdtp-right-button:focus,.dl-abdtp-right-button:hover,.dl-abdtp-up-button:focus,.dl-abdtp-up-button:hover,.dl-abdtp-view-label:focus{background:rgba(0,0,0,.04)}.dl-abdtp-future,.dl-abdtp-past{color:rgba(0,0,0,.04)}.dl-abdtp-now,.dl-abdtp-now.disabled,.dl-abdtp-now.disabled:hover,.dl-abdtp-now:hover{border-radius:999px;border:1px solid rgba(0,0,0,.25)}.dl-abdtp-selected{color:#fff;background:rgba(0,82,204,.75)}.dl-abdtp-selected:focus,.dl-abdtp-selected:hover{background:#0052cc}.dl-abdtp-disabled{cursor:default;color:rgba(0,0,0,.25)}"]
            }] }
];
/** @nocollapse */
DlDateTimePickerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: DlDateAdapter },
    { type: DlYearModelProvider },
    { type: DlMonthModelProvider },
    { type: DlDayModelProvider },
    { type: DlHourModelProvider },
    { type: DlMinuteModelProvider }
];
DlDateTimePickerComponent.propDecorators = {
    change: [{ type: Output }],
    leftIconClass: [{ type: Input }],
    maxView: [{ type: Input }],
    minView: [{ type: Input }],
    minuteStep: [{ type: Input }],
    rightIconClass: [{ type: Input }],
    selectFilter: [{ type: Input }],
    startDate: [{ type: Input }],
    startView: [{ type: Input }],
    upIconClass: [{ type: Input }]
};
if (false) {
    /**
     * Change listener callback functions registered
     * via `registerOnChange`
     * \@internal
     *
     * @type {?}
     * @private
     */
    DlDateTimePickerComponent.prototype._changed;
    /**
     * Model for the current view.
     *
     * \@internal
     *
     * @type {?}
     */
    DlDateTimePickerComponent.prototype._model;
    /**
     * Maps view name to the next view (the view for the next smallest increment of time).
     * \@internal
     *
     * @type {?}
     * @private
     */
    DlDateTimePickerComponent.prototype._nextView;
    /**
     * Maps view name to the previous view (the view for the next largest increment of time).
     * \@internal
     *
     * @type {?}
     * @private
     */
    DlDateTimePickerComponent.prototype._previousView;
    /**
     * Touch listener callback functions registered
     * via `registerOnChange`
     * \@internal
     *
     * @type {?}
     * @private
     */
    DlDateTimePickerComponent.prototype._touched;
    /**
     * Stores the selected value for this picker.
     * \@internal
     *
     * @type {?}
     * @private
     */
    DlDateTimePickerComponent.prototype._value;
    /**
     * Maps view name to the model provider for that view.
     * \@internal
     *
     * @type {?}
     * @private
     */
    DlDateTimePickerComponent.prototype._viewToModelProvider;
    /**
     * Emits when a `change` event when date/time is selected or
     * the value of the date/time picker changes.
     *
     * @type {?}
     */
    DlDateTimePickerComponent.prototype.change;
    /**
     * Specifies the classes used to display the left icon.
     *
     * This component uses OPENICONIC https://useiconic.com/open
     * by default but any icon library may be used.
     * @type {?}
     */
    DlDateTimePickerComponent.prototype.leftIconClass;
    /**
     * The highest view that the date/time picker can show.
     * Setting this to a view less than year could make it more
     * difficult for the end-user to navigate to certain dates.
     * @type {?}
     */
    DlDateTimePickerComponent.prototype.maxView;
    /**
     * The view that will be used for date/time selection.
     *
     * The default of `minute  means that selection will not happen
     * until the end-user clicks on a cell in the minute view.
     *
     * for example, if you want the end-user to select a only day (date),
     * setting `minView` to `day` will cause selection to happen when the
     * end-user selects a cell in the day view.
     *
     * NOTE: This must be set lower than or equal to `startView'
     * @type {?}
     */
    DlDateTimePickerComponent.prototype.minView;
    /**
     * The number of minutes between each `.dl-abdtp-minute` button.
     *
     * Must be greater than `0` and less than `60`.
     * @type {?}
     */
    DlDateTimePickerComponent.prototype.minuteStep;
    /**
     * Specifies the classes used to display the right icon.
     *
     * This component uses OPENICONIC https://useiconic.com/open
     * by default but any icon library may be used.
     * @type {?}
     */
    DlDateTimePickerComponent.prototype.rightIconClass;
    /**
     *  Determine whether or not the `DateButton` is selectable by the end user.
     * @type {?}
     */
    DlDateTimePickerComponent.prototype.selectFilter;
    /**
     *  Start at the view containing startDate when no value is selected.
     * @type {?}
     */
    DlDateTimePickerComponent.prototype.startDate;
    /**
     * The initial view that the date/time picker will show.
     * The picker will also return to this view after a date/time
     * is selected.
     *
     * NOTE: This must be set lower than or equal to `maxView'
     * @type {?}
     */
    DlDateTimePickerComponent.prototype.startView;
    /**
     * Specifies the classes used to display the up icon.
     *
     * This component uses OPENICONIC https://useiconic.com/open
     * by default but any icon library may be used.
     * @type {?}
     */
    DlDateTimePickerComponent.prototype.upIconClass;
    /**
     * @type {?}
     * @private
     */
    DlDateTimePickerComponent.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    DlDateTimePickerComponent.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    DlDateTimePickerComponent.prototype._dateAdapter;
    /**
     * @type {?}
     * @private
     */
    DlDateTimePickerComponent.prototype.yearModelComponent;
    /**
     * @type {?}
     * @private
     */
    DlDateTimePickerComponent.prototype.monthModelComponent;
    /**
     * @type {?}
     * @private
     */
    DlDateTimePickerComponent.prototype.dayModelComponent;
    /**
     * @type {?}
     * @private
     */
    DlDateTimePickerComponent.prototype.hourModelComponent;
    /**
     * @type {?}
     * @private
     */
    DlDateTimePickerComponent.prototype.minuteModelComponent;
}
/**
 * \@internal
 * @param {?} value
 * @return {?}
 */
function hasValue(value) {
    return (typeof value !== 'undefined') && (value !== null);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGwtZGF0ZS10aW1lLXBpY2tlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLWJvb3RzdHJhcC1kYXRldGltZXBpY2tlci8iLCJzb3VyY2VzIjpbImRsLWRhdGUtdGltZS1waWNrZXIvZGwtZGF0ZS10aW1lLXBpY2tlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBU0EsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUdOLE1BQU0sRUFFUCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQXVCLGlCQUFpQixFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDdkUsT0FBTyxLQUFLLE9BQU8sTUFBTSxRQUFRLENBQUM7QUFDbEMsT0FBTyxFQUFDLElBQUksRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQ3BDLE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFDdEMsT0FBTyxFQUFDLHNCQUFzQixFQUFDLE1BQU0sOEJBQThCLENBQUM7QUFJcEUsT0FBTyxFQUFDLGtCQUFrQixFQUFDLE1BQU0seUJBQXlCLENBQUM7QUFDM0QsT0FBTyxFQUFDLG1CQUFtQixFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFDN0QsT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0sNEJBQTRCLENBQUM7QUFDakUsT0FBTyxFQUFDLG9CQUFvQixFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDL0QsT0FBTyxFQUFDLG1CQUFtQixFQUFDLE1BQU0sMEJBQTBCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7TUFldkQsTUFBTSxHQUFHLE9BQU87Ozs7Ozs7OztNQVVoQiw0QkFBNEIsR0FBRztJQUNuQyxXQUFXLEVBQUUsUUFBUTtJQUNyQixXQUFXLEVBQUUsUUFBUTtJQUNyQixZQUFZLEVBQUUsU0FBUztJQUN2QixTQUFTLEVBQUUsTUFBTTtJQUNq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LENBQUMsT0FBTyxLQUFLLEtBQUssV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDLENBQUM7QUFDNUQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQgRGFsZSBMb3R0cyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5kYWxlbG90dHMuY29tXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9naXRodWIuY29tL2RhbGVsb3R0cy9hbmd1bGFyLWJvb3RzdHJhcC1kYXRldGltZXBpY2tlci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgTmdab25lLFxuICBPbkNoYW5nZXMsXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQge0NvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0ICogYXMgX21vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHt0YWtlfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge0RsRGF0ZUFkYXB0ZXJ9IGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0IHtEbERhdGVUaW1lUGlja2VyQ2hhbmdlfSBmcm9tICcuL2RsLWRhdGUtdGltZS1waWNrZXItY2hhbmdlJztcbmltcG9ydCB7RGF0ZUJ1dHRvbn0gZnJvbSAnLi9kbC1kYXRlLXRpbWUtcGlja2VyLWRhdGUtYnV0dG9uJztcbmltcG9ydCB7RGxEYXRlVGltZVBpY2tlck1vZGVsfSBmcm9tICcuL2RsLWRhdGUtdGltZS1waWNrZXItbW9kZWwnO1xuaW1wb3J0IHtEbE1vZGVsUHJvdmlkZXJ9IGZyb20gJy4vZGwtbW9kZWwtcHJvdmlkZXInO1xuaW1wb3J0IHtEbERheU1vZGVsUHJvdmlkZXJ9IGZyb20gJy4vZGwtbW9kZWwtcHJvdmlkZXItZGF5JztcbmltcG9ydCB7RGxIb3VyTW9kZWxQcm92aWRlcn0gZnJvbSAnLi9kbC1tb2RlbC1wcm92aWRlci1ob3VyJztcbmltcG9ydCB7RGxNaW51dGVNb2RlbFByb3ZpZGVyfSBmcm9tICcuL2RsLW1vZGVsLXByb3ZpZGVyLW1pbnV0ZSc7XG5pbXBvcnQge0RsTW9udGhNb2RlbFByb3ZpZGVyfSBmcm9tICcuL2RsLW1vZGVsLXByb3ZpZGVyLW1vbnRoJztcbmltcG9ydCB7RGxZZWFyTW9kZWxQcm92aWRlcn0gZnJvbSAnLi9kbC1tb2RlbC1wcm92aWRlci15ZWFyJztcblxuLyoqXG4gKiBXb3JrIGFyb3VuZCBmb3IgbW9tZW50IG5hbWVzcGFjZSBjb25mbGljdCB3aGVuIHVzZWQgd2l0aCB3ZWJwYWNrIGFuZCByb2xsdXAuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2RoZXJnZXMvbmctcGFja2Fnci9pc3N1ZXMvMTYzXG4gKlxuICogRGVwZW5kaW5nIG9uIHdoZXRoZXIgcm9sbHVwIGlzIHVzZWQsIG1vbWVudCBuZWVkcyB0byBiZSBpbXBvcnRlZCBkaWZmZXJlbnRseS5cbiAqIFNpbmNlIE1vbWVudC5qcyBkb2Vzbid0IGhhdmUgYSBkZWZhdWx0IGV4cG9ydCwgd2Ugbm9ybWFsbHkgbmVlZCB0byBpbXBvcnQgdXNpbmdcbiAqIHRoZSBgKiBhc2BzeW50YXguXG4gKlxuICogcm9sbHVwIGNyZWF0ZXMgYSBzeW50aGV0aWMgZGVmYXVsdCBtb2R1bGUgYW5kIHdlIHRodXMgbmVlZCB0byBpbXBvcnQgaXQgdXNpbmdcbiAqIHRoZSBgZGVmYXVsdCBhc2Agc3ludGF4LlxuICpcbiAqIEBpbnRlcm5hbFxuICoqL1xuY29uc3QgbW9tZW50ID0gX21vbWVudDtcblxuXG4vKipcbiAqIE1hcHMga2V5IGNvZGVzIHRvIHRoZSBtb2RlbCBwcm92aWRlciBmdW5jdGlvbiBuYW1lXG4gKiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgdG8gcGVyZm9ybSB0aGUgYWN0aW9uLlxuICpcbiAqIEBpbnRlcm5hbFxuICoqL1xuXG5jb25zdCBrZXlDb2RlVG9Nb2RlbFByb3ZpZGVyTWV0aG9kID0ge1xuICAnQXJyb3dEb3duJzogJ2dvRG93bicsXG4gICdBcnJvd0xlZnQnOiAnZ29MZWZ0JyxcbiAgJ0Fycm93UmlnaHQnOiAnZ29SaWdodCcsXG4gICdBcnJvd1VwJzogJ2dvVXAnLFxuICAnRG93bic6ICdnb0Rvd24nLFxuICAnRW5kJzogJ2dvRW5kJyxcbiAgJ0hvbWUnOiAnZ29Ib21lJyxcbiAgJ0xlZnQnOiAnZ29MZWZ0JyxcbiAgJ1BhZ2VEb3duJzogJ3BhZ2VEb3duJyxcbiAgJ1BhZ2VVcCc6ICdwYWdlVXAnLFxuICAnUmlnaHQnOiAnZ29SaWdodCcsXG4gICdVcCc6ICdnb1VwJyxcbiAgMzM6ICdwYWdlVXAnLFxuICAzNDogJ3BhZ2VEb3duJyxcbiAgMzU6ICdnb0VuZCcsXG4gIDM2OiAnZ29Ib21lJyxcbiAgMzc6ICdnb0xlZnQnLFxuICAzODogJ2dvVXAnLFxuICAzOTogJ2dvUmlnaHQnLFxuICA0MDogJ2dvRG93bicsXG59O1xuXG5cbi8qKlxuICogTGlzdCBvZiB2aWV3IG5hbWVzIGZvciB0aGUgY2FsZW5kYXIuXG4gKlxuICogVGhpcyBsaXN0IG11c3QgYmUgaW4gb3JkZXIgZnJvbVxuICogc21hbGxlc3QgaW5jcmVtZW50IG9mIHRpbWUgdG8gbGFyZ2VzdCBpbmNyZW1lbnQgb2YgdGltZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqKi9cbmNvbnN0IFZJRVdTID0gW1xuICAnbWludXRlJyxcbiAgJ2hvdXInLFxuICAnZGF5JyxcbiAgJ21vbnRoJyxcbiAgJ3llYXInXG5dO1xuXG4vKipcbiAqIENvbXBvbmVudCB0aGF0IHByb3ZpZGVzIGFsbCBvZiB0aGUgdXNlciBmYWNpbmcgZnVuY3Rpb25hbGl0eSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAqL1xuXG5AQ29tcG9uZW50KHtcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgIHVzZUV4aXN0aW5nOiBEbERhdGVUaW1lUGlja2VyQ29tcG9uZW50LFxuICAgICAgbXVsdGk6IHRydWVcbiAgICB9XG4gIF0sXG4gIHNlbGVjdG9yOiAnZGwtZGF0ZS10aW1lLXBpY2tlcicsXG4gIHN0eWxlVXJsczogWycuL2RsLWRhdGUtdGltZS1waWNrZXIuY29tcG9uZW50LnNjc3MnXSxcbiAgdGVtcGxhdGVVcmw6ICcuL2RsLWRhdGUtdGltZS1waWNrZXIuY29tcG9uZW50Lmh0bWwnLFxufSlcbmV4cG9ydCBjbGFzcyBEbERhdGVUaW1lUGlja2VyQ29tcG9uZW50PEQ+IGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkluaXQsIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcblxuICAvKipcbiAgICogQ2hhbmdlIGxpc3RlbmVyIGNhbGxiYWNrIGZ1bmN0aW9ucyByZWdpc3RlcmVkXG4gICAqIHZpYSBgcmVnaXN0ZXJPbkNoYW5nZWBcbiAgICogQGludGVybmFsXG4gICAqKi9cbiAgcHJpdmF0ZSBfY2hhbmdlZDogKCh2YWx1ZTogRCkgPT4gdm9pZClbXSA9IFtdO1xuICAvKipcbiAgICogTW9kZWwgZm9yIHRoZSBjdXJyZW50IHZpZXcuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiovXG4gIF9tb2RlbDogRGxEYXRlVGltZVBpY2tlck1vZGVsO1xuICAvKipcbiAgICogTWFwcyB2aWV3IG5hbWUgdG8gdGhlIG5leHQgdmlldyAodGhlIHZpZXcgZm9yIHRoZSBuZXh0IHNtYWxsZXN0IGluY3JlbWVudCBvZiB0aW1lKS5cbiAgICogQGludGVybmFsXG4gICAqKi9cbiAgcHJpdmF0ZSBfbmV4dFZpZXcgPSB7XG4gICAgJ3llYXInOiAnbW9udGgnLFxuICAgICdtb250aCc6ICdkYXknLFxuICAgICdkYXknOiAnaG91cicsXG4gICAgJ2hvdXInOiAnbWludXRlJ1xuICB9O1xuICAvKipcbiAgICogTWFwcyB2aWV3IG5hbWUgdG8gdGhlIHByZXZpb3VzIHZpZXcgKHRoZSB2aWV3IGZvciB0aGUgbmV4dCBsYXJnZXN0IGluY3JlbWVudCBvZiB0aW1lKS5cbiAgICogQGludGVybmFsXG4gICAqKi9cbiAgcHJpdmF0ZSBfcHJldmlvdXNWaWV3ID0ge1xuICAgICdtaW51dGUnOiAnaG91cicsXG4gICAgJ2hvdXInOiAnZGF5JyxcbiAgICAnZGF5JzogJ21vbnRoJyxcbiAgICAnbW9udGgnOiAneWVhcidcbiAgfTtcbiAgLyoqXG4gICAqIFRvdWNoIGxpc3RlbmVyIGNhbGxiYWNrIGZ1bmN0aW9ucyByZWdpc3RlcmVkXG4gICAqIHZpYSBgcmVnaXN0ZXJPbkNoYW5nZWBcbiAgICogQGludGVybmFsXG4gICAqKi9cbiAgcHJpdmF0ZSBfdG91Y2hlZDogKCgpID0+IHZvaWQpW10gPSBbXTtcbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgc2VsZWN0ZWQgdmFsdWUgZm9yIHRoaXMgcGlja2VyLlxuICAgKiBAaW50ZXJuYWxcbiAgICoqL1xuICBwcml2YXRlIF92YWx1ZTogRDtcbiAgLyoqXG4gICAqIE1hcHMgdmlldyBuYW1lIHRvIHRoZSBtb2RlbCBwcm92aWRlciBmb3IgdGhhdCB2aWV3LlxuICAgKiBAaW50ZXJuYWxcbiAgICoqL1xuICBwcml2YXRlIHJlYWRvbmx5IF92aWV3VG9Nb2RlbFByb3ZpZGVyOiB7XG4gICAgeWVhcjogRGxNb2RlbFByb3ZpZGVyO1xuICAgIG1vbnRoOiBEbE1vZGVsUHJvdmlkZXI7XG4gICAgZGF5OiBEbE1vZGVsUHJvdmlkZXI7XG4gICAgaG91cjogRGxNb2RlbFByb3ZpZGVyO1xuICAgIG1pbnV0ZTogRGxNb2RlbFByb3ZpZGVyO1xuICB9O1xuICAvKipcbiAgICogRW1pdHMgd2hlbiBhIGBjaGFuZ2VgIGV2ZW50IHdoZW4gZGF0ZS90aW1lIGlzIHNlbGVjdGVkIG9yXG4gICAqIHRoZSB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlciBjaGFuZ2VzLlxuICAgKiovXG4gIEBPdXRwdXQoKVxuICByZWFkb25seSBjaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPERsRGF0ZVRpbWVQaWNrZXJDaGFuZ2U8RD4+KCk7XG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGNsYXNzZXMgdXNlZCB0byBkaXNwbGF5IHRoZSBsZWZ0IGljb24uXG4gICAqXG4gICAqIFRoaXMgY29tcG9uZW50IHVzZXMgT1BFTklDT05JQyBodHRwczovL3VzZWljb25pYy5jb20vb3BlblxuICAgKiBieSBkZWZhdWx0IGJ1dCBhbnkgaWNvbiBsaWJyYXJ5IG1heSBiZSB1c2VkLlxuICAgKi9cbiAgQElucHV0KClcbiAgbGVmdEljb25DbGFzczogc3RyaW5nIHwgc3RyaW5nW10gfCBTZXQ8c3RyaW5nPiB8IHt9ID0gW1xuICAgICdvaScsXG4gICAgJ29pLWNoZXZyb24tbGVmdCdcbiAgXTtcbiAgLyoqXG4gICAqIFRoZSBoaWdoZXN0IHZpZXcgdGhhdCB0aGUgZGF0ZS90aW1lIHBpY2tlciBjYW4gc2hvdy5cbiAgICogU2V0dGluZyB0aGlzIHRvIGEgdmlldyBsZXNzIHRoYW4geWVhciBjb3VsZCBtYWtlIGl0IG1vcmVcbiAgICogZGlmZmljdWx0IGZvciB0aGUgZW5kLXVzZXIgdG8gbmF2aWdhdGUgdG8gY2VydGFpbiBkYXRlcy5cbiAgICovXG4gIEBJbnB1dCgpXG4gIG1heFZpZXc6ICd5ZWFyJyB8ICdtb250aCcgfCAnZGF5JyB8ICdob3VyJyB8ICdtaW51dGUnID0gJ3llYXInO1xuICAvKipcbiAgICogVGhlIHZpZXcgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGRhdGUvdGltZSBzZWxlY3Rpb24uXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IG9mIGBtaW51dGUgIG1lYW5zIHRoYXQgc2VsZWN0aW9uIHdpbGwgbm90IGhhcHBlblxuICAgKiB1bnRpbCB0aGUgZW5kLXVzZXIgY2xpY2tzIG9uIGEgY2VsbCBpbiB0aGUgbWludXRlIHZpZXcuXG4gICAqXG4gICAqIGZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0aGUgZW5kLXVzZXIgdG8gc2VsZWN0IGEgb25seSBkYXkgKGRhdGUpLFxuICAgKiBzZXR0aW5nIGBtaW5WaWV3YCB0byBgZGF5YCB3aWxsIGNhdXNlIHNlbGVjdGlvbiB0byBoYXBwZW4gd2hlbiB0aGVcbiAgICogZW5kLXVzZXIgc2VsZWN0cyBhIGNlbGwgaW4gdGhlIGRheSB2aWV3LlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIG11c3QgYmUgc2V0IGxvd2VyIHRoYW4gb3IgZXF1YWwgdG8gYHN0YXJ0VmlldydcbiAgICovXG4gIEBJbnB1dCgpXG4gIG1pblZpZXc6ICd5ZWFyJyB8ICdtb250aCcgfCAnZGF5JyB8ICdob3VyJyB8ICdtaW51dGUnID0gJ21pbnV0ZSc7XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIG1pbnV0ZXMgYmV0d2VlbiBlYWNoIGAuZGwtYWJkdHAtbWludXRlYCBidXR0b24uXG4gICAqXG4gICAqIE11c3QgYmUgZ3JlYXRlciB0aGFuIGAwYCBhbmQgbGVzcyB0aGFuIGA2MGAuXG4gICAqL1xuICBASW5wdXQoKVxuICBtaW51dGVTdGVwID0gNTtcbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgY2xhc3NlcyB1c2VkIHRvIGRpc3BsYXkgdGhlIHJpZ2h0IGljb24uXG4gICAqXG4gICAqIFRoaXMgY29tcG9uZW50IHVzZXMgT1BFTklDT05JQyBodHRwczovL3VzZWljb25pYy5jb20vb3BlblxuICAgKiBieSBkZWZhdWx0IGJ1dCBhbnkgaWNvbiBsaWJyYXJ5IG1heSBiZSB1c2VkLlxuICAgKi9cbiAgQElucHV0KClcbiAgcmlnaHRJY29uQ2xhc3MgPSBbXG4gICAgJ29pJyxcbiAgICAnb2ktY2hldnJvbi1yaWdodCdcbiAgXTtcblxuICAvKiB0c2xpbnQ6ZGlzYWJsZTptZW1iZXItb3JkZXJpbmcgKi9cbiAgLyoqXG4gICAqICBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgdGhlIGBEYXRlQnV0dG9uYCBpcyBzZWxlY3RhYmxlIGJ5IHRoZSBlbmQgdXNlci5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNlbGVjdEZpbHRlcjogKGRhdGVCdXR0b246IERhdGVCdXR0b24sIHZpZXdOYW1lOiBzdHJpbmcpID0+IGJvb2xlYW4gPSAoKSA9PiB0cnVlXG5cbiAgLyoqXG4gICAqICBTdGFydCBhdCB0aGUgdmlldyBjb250YWluaW5nIHN0YXJ0RGF0ZSB3aGVuIG5vIHZhbHVlIGlzIHNlbGVjdGVkLlxuICAgKi9cbiAgQElucHV0KClcbiAgc3RhcnREYXRlOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBpbml0aWFsIHZpZXcgdGhhdCB0aGUgZGF0ZS90aW1lIHBpY2tlciB3aWxsIHNob3cuXG4gICAqIFRoZSBwaWNrZXIgd2lsbCBhbHNvIHJldHVybiB0byB0aGlzIHZpZXcgYWZ0ZXIgYSBkYXRlL3RpbWVcbiAgICogaXMgc2VsZWN0ZWQuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgbXVzdCBiZSBzZXQgbG93ZXIgdGhhbiBvciBlcXVhbCB0byBgbWF4VmlldydcbiAgICovXG4gIEBJbnB1dCgpXG4gIHN0YXJ0VmlldzogJ3llYXInIHwgJ21vbnRoJyB8ICdkYXknIHwgJ2hvdXInIHwgJ21pbnV0ZScgPSAnZGF5JztcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBjbGFzc2VzIHVzZWQgdG8gZGlzcGxheSB0aGUgdXAgaWNvbi5cbiAgICpcbiAgICogVGhpcyBjb21wb25lbnQgdXNlcyBPUEVOSUNPTklDIGh0dHBzOi8vdXNlaWNvbmljLmNvbS9vcGVuXG4gICAqIGJ5IGRlZmF1bHQgYnV0IGFueSBpY29uIGxpYnJhcnkgbWF5IGJlIHVzZWQuXG4gICAqL1xuICBASW5wdXQoKVxuICB1cEljb25DbGFzcyA9IFtcbiAgICAnb2knLFxuICAgICdvaS1jaGV2cm9uLXRvcCdcbiAgXTtcblxuICAvKipcbiAgICogVXNlZCB0byBjb25zdHJ1Y3QgYSBuZXcgaW5zdGFuY2Ugb2YgYSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKlxuICAgKiBAcGFyYW0gX2VsZW1lbnRSZWZcbiAgICogIHJlZmVyZW5jZSB0byB0aGlzIGVsZW1lbnQuXG4gICAqIEBwYXJhbSBfbmdab25lXG4gICAqICByZWZlcmVuY2UgdG8gYW4gTmdab25lIGluc3RhbmNlIHVzZWQgdG8gc2VsZWN0IHRoZSBhY3RpdmUgZWxlbWVudCBvdXRzaWRlIG9mIGFuZ3VsYXIuXG4gICAqIEBwYXJhbSBfZGF0ZUFkYXB0ZXJcbiAgICogIGRhdGUgYWRhcHRlciBmb3IgdGhlIGRhdGUgdHlwZSBpbiB0aGUgbW9kZWwuXG4gICAqIEBwYXJhbSB5ZWFyTW9kZWxDb21wb25lbnRcbiAgICogIHByb3ZpZGVyIGZvciB0aGUgeWVhciB2aWV3IG1vZGVsLlxuICAgKiBAcGFyYW0gbW9udGhNb2RlbENvbXBvbmVudFxuICAgKiAgcHJvdmlkZXIgZm9yIHRoZSBtb250aCB2aWV3IG1vZGVsLlxuICAgKiBAcGFyYW0gZGF5TW9kZWxDb21wb25lbnRcbiAgICogIHByb3ZpZGVyIGZvciB0aGUgZGF5IHZpZXcgbW9kZWwuXG4gICAqIEBwYXJhbSBob3VyTW9kZWxDb21wb25lbnRcbiAgICogIHByb3ZpZGVyIGZvciB0aGUgaG91ciB2aWV3IG1vZGVsLlxuICAgKiBAcGFyYW0gbWludXRlTW9kZWxDb21wb25lbnRcbiAgICogIHByb3ZpZGVyIGZvciB0aGUgbWludXRlIHZpZXcgbW9kZWwuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfZGF0ZUFkYXB0ZXI6IERsRGF0ZUFkYXB0ZXI8RD4sXG4gICAgICAgICAgICAgIHByaXZhdGUgeWVhck1vZGVsQ29tcG9uZW50OiBEbFllYXJNb2RlbFByb3ZpZGVyLFxuICAgICAgICAgICAgICBwcml2YXRlIG1vbnRoTW9kZWxDb21wb25lbnQ6IERsTW9udGhNb2RlbFByb3ZpZGVyLFxuICAgICAgICAgICAgICBwcml2YXRlIGRheU1vZGVsQ29tcG9uZW50OiBEbERheU1vZGVsUHJvdmlkZXIsXG4gICAgICAgICAgICAgIHByaXZhdGUgaG91ck1vZGVsQ29tcG9uZW50OiBEbEhvdXJNb2RlbFByb3ZpZGVyLFxuICAgICAgICAgICAgICBwcml2YXRlIG1pbnV0ZU1vZGVsQ29tcG9uZW50OiBEbE1pbnV0ZU1vZGVsUHJvdmlkZXIpIHtcblxuICAgIHRoaXMuX3ZpZXdUb01vZGVsUHJvdmlkZXIgPSB7XG4gICAgICB5ZWFyOiB5ZWFyTW9kZWxDb21wb25lbnQsXG4gICAgICBtb250aDogbW9udGhNb2RlbENvbXBvbmVudCxcbiAgICAgIGRheTogZGF5TW9kZWxDb21wb25lbnQsXG4gICAgICBob3VyOiBob3VyTW9kZWxDb21wb25lbnQsXG4gICAgICBtaW51dGU6IG1pbnV0ZU1vZGVsQ29tcG9uZW50LFxuICAgIH07XG4gIH1cblxuICAvKiB0c2xpbnQ6ZW5hYmxlOm1lbWJlci1vcmRlcmluZyAqL1xuICAvKipcbiAgICogU2V0J3MgdGhlIG1vZGVsIGZvciB0aGUgY3VycmVudCB2aWV3IGFmdGVyIGFwcGx5aW5nIHRoZSBzZWxlY3Rpb24gZmlsdGVyLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICoqL1xuICBwcml2YXRlIHNldCBtb2RlbChtb2RlbDogRGxEYXRlVGltZVBpY2tlck1vZGVsKSB7XG4gICAgdGhpcy5fbW9kZWwgPSB0aGlzLmFwcGx5U2VsZWN0RmlsdGVyKG1vZGVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGBEYCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlciBvciB1bmRlZmluZWQvbnVsbCBpZiBubyB2YWx1ZSBpcyBzZXQuXG4gICAqKi9cbiAgZ2V0IHZhbHVlKCk6IEQge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyIGFuZCBlbWl0cyBhIGNoYW5nZSBldmVudCBpZiB0aGVcbiAgICogbmV3IHZhbHVlIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAgICoqL1xuICBzZXQgdmFsdWUodmFsdWU6IEQpIHtcbiAgICBpZiAodGhpcy5fdmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5tb2RlbCA9IHRoaXMuX3ZpZXdUb01vZGVsUHJvdmlkZXJbdGhpcy5fbW9kZWwudmlld05hbWVdLmdldE1vZGVsKHRoaXMuZ2V0U3RhcnREYXRlKCksIHRoaXMudmFsdWVPZik7XG4gICAgICB0aGlzLl9jaGFuZ2VkLmZvckVhY2goZiA9PiBmKHZhbHVlKSk7XG4gICAgICB0aGlzLmNoYW5nZS5lbWl0KG5ldyBEbERhdGVUaW1lUGlja2VyQ2hhbmdlPEQ+KHZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYG1pbGxpc2Vjb25kc2AgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBwaWNrZXIgb3IgdW5kZWZpbmVkL251bGwgaWYgbm8gdmFsdWUgaXMgc2V0LlxuICAgKiovXG4gIGdldCB2YWx1ZU9mKCk6IG51bWJlciB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl9kYXRlQWRhcHRlci50b01pbGxpc2Vjb25kcyh0aGlzLl92YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgYHNlbGVjdGlvbkZpbHRlcmAgYnkgYWRkaW5nIHRoZSBgZGwtYWJkdHAtZGlzYWJsZWRgXG4gICAqIGNsYXNzIHRvIGFueSBgRGF0ZUJ1dHRvbmAgd2hlcmUgYHNlbGVjdEZpbHRlcmAgcmV0dXJuZWQgZmFsc2UuXG4gICAqXG4gICAqIEBwYXJhbSBtb2RlbFxuICAgKiAgdGhlIG5ldyBtb2RlbFxuICAgKlxuICAgKiBAcmV0dXJuc1xuICAgKiAgdGhlIHN1cHBsaWVkIG1vZGVsIHdpdGggemVybyBvciBtb3JlIGBEYXRlQnV0dG9uYCdzXG4gICAqICBoYXZpbmcgdGhlIGBkbC1hYmR0cC1kaXNhYmxlZGAgY2xhc3Mgc2V0IHRvIGB0cnVlYCBpZiB0aGVcbiAgICogIHNlbGVjdGlvbiBmb3IgdGhhdCBkYXRlIHNob3VsZCBiZSBkaXNhYmxlZC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIGFwcGx5U2VsZWN0RmlsdGVyKG1vZGVsOiBEbERhdGVUaW1lUGlja2VyTW9kZWwpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIGlmICh0aGlzLnNlbGVjdEZpbHRlcikge1xuICAgICAgbW9kZWwucm93cyA9IG1vZGVsLnJvd3MubWFwKChyb3cpID0+IHtcbiAgICAgICAgcm93LmNlbGxzLm1hcCgoZGF0ZUJ1dHRvbjogRGF0ZUJ1dHRvbikgPT4ge1xuICAgICAgICAgIGNvbnN0IGRpc2FibGVkID0gIXRoaXMuc2VsZWN0RmlsdGVyKGRhdGVCdXR0b24sIG1vZGVsLnZpZXdOYW1lKTtcbiAgICAgICAgICBkYXRlQnV0dG9uLmNsYXNzZXNbJ2RsLWFiZHRwLWRpc2FibGVkJ10gPSBkaXNhYmxlZDtcbiAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGRhdGVCdXR0b24uY2xhc3Nlc1snYXJpYS1kaXNhYmxlZCddID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRhdGVCdXR0b247XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcm93O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvY3VzZXMgdGhlIGAuZGwtYWJkdHAtYWN0aXZlYCBjZWxsIGFmdGVyIHRoZSBtaWNyb3Rhc2sgcXVldWUgaXMgZW1wdHkuXG4gICAqIEBpbnRlcm5hbFxuICAgKiovXG4gIHByaXZhdGUgZm9jdXNBY3RpdmVDZWxsKCkge1xuICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICB0aGlzLl9uZ1pvbmUub25TdGFibGUuYXNPYnNlcnZhYmxlKCkucGlwZSh0YWtlKDEpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmRsLWFiZHRwLWFjdGl2ZScpLmZvY3VzKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBzdGFydCBkYXRlIGZvciB0aGUgcGlja2VyLlxuICAgKiBAaW50ZXJuYWxcbiAgICoqL1xuICBwcml2YXRlIGdldFN0YXJ0RGF0ZSgpIHtcbiAgICBpZiAoaGFzVmFsdWUodGhpcy5fdmFsdWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0ZUFkYXB0ZXIudG9NaWxsaXNlY29uZHModGhpcy5fdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaGFzVmFsdWUodGhpcy5zdGFydERhdGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydERhdGU7XG4gICAgfVxuICAgIHJldHVybiBtb21lbnQoKS52YWx1ZU9mKCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBzdGFydCB2aWV3IGZvciB0aGUgcGlja2VyXG4gICAqIEByZXR1cm5zXG4gICAqICB0aGUgbGFyZ2VzdCB0aW1lIGluY3JlbWVudCB2aWV3IGJldHdlZW4gdGhlIGBtaW5WaWV3YCBvciBgbWludXRlYCB2aWV3IGFuZCB0aGUgYHN0YXJ0Vmlld2Agb3IgYGRheWAgdmlldy5cbiAgICovXG4gIHByaXZhdGUgZ2V0U3RhcnRWaWV3KCk6IHN0cmluZyB7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IE1hdGgubWF4KFZJRVdTLmluZGV4T2YodGhpcy5taW5WaWV3IHx8ICdtaW51dGUnKSwgVklFV1MuaW5kZXhPZih0aGlzLnN0YXJ0VmlldyB8fCAnZGF5JykpO1xuICAgIHJldHVybiBWSUVXU1tzdGFydEluZGV4XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBhbGwgcmVnaXN0ZXJlZCBgdG91Y2hgIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICogQGludGVybmFsXG4gICAqKi9cbiAgcHJpdmF0ZSBvblRvdWNoKCkge1xuICAgIHRoaXMuX3RvdWNoZWQuZm9yRWFjaCgob25Ub3VjaGVkKSA9PiBvblRvdWNoZWQoKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVjZWl2ZXMgY29uZmlndXJhdGlvbiBjaGFuZ2VzIGRldGVjdGVkIGJ5IEFuZ3VsYXIgYW5kIHBhc3NlcyB0aGUgY2hhbmdlcyBvblxuICAgKiB0byB0aGUgbW9kZWwgcHJvdmlkZXJzIHNvIHRoZSBwcm92aWRlciBpcyBhd2FyZSBvZiBhbnkgbmVjZXNzYXJ5IGNvbmZpZ3VyYXRpb25cbiAgICogY2hhbmdlcyAoaS5lLiBtaW51dGVTdGVwKVxuICAgKlxuICAgKiBAcGFyYW0gY2hhbmdlc1xuICAgKiAgdGhlIGlucHV0IGNoYW5nZXMgZGV0ZWN0ZWQgYnkgQW5ndWxhci5cbiAgICovXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl92aWV3VG9Nb2RlbFByb3ZpZGVyKVxuICAgICAgLm1hcCgoa2V5KSA9PiB0aGlzLl92aWV3VG9Nb2RlbFByb3ZpZGVyW2tleV0pXG4gICAgICAuZm9yRWFjaCgocHJvdmlkZXI6IERsTW9kZWxQcm92aWRlcikgPT4gcHJvdmlkZXIub25DaGFuZ2VzKGNoYW5nZXMpKTtcblxuICAgIGlmICh0aGlzLl9tb2RlbCkgeyAvLyBvbmx5IHVwZGF0ZSB0aGUgbW9kZWwgYWZ0ZXIgbmdPbkluaXQgaGFzIHNldCBpdCB0aGUgZmlyc3QgdGltZS5cbiAgICAgIHRoaXMubW9kZWwgPSB0aGlzLl92aWV3VG9Nb2RlbFByb3ZpZGVyW3RoaXMuX21vZGVsLnZpZXdOYW1lXS5nZXRNb2RlbCh0aGlzLl9tb2RlbC5hY3RpdmVEYXRlLCB0aGlzLnZhbHVlT2YpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbml0aWFsIG1vZGVsLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICoqL1xuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLm1vZGVsID0gdGhpcy5fdmlld1RvTW9kZWxQcm92aWRlclt0aGlzLmdldFN0YXJ0VmlldygpXS5nZXRNb2RlbCh0aGlzLmdldFN0YXJ0RGF0ZSgpLCB0aGlzLnZhbHVlT2YpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgY2xpY2sgKGFuZCBlbnRlciAmIHNwYWNlIGtleSBkb3duKSBldmVudHMgb24gdGhlIGRhdGUgZWxlbWVudHMuXG4gICAqXG4gICAqIElmIHRoZSBjdXJyZW50IHZpZXcgaXMgdGhlIG1pbmltdW0gdmlldyB0aGVuIHRoZSBkYXRlIHZhbHVlIGlzIHNlbGVjdGVkXG4gICAqIGFuZCB0aGUgcGlja2VyIHJldHVybnMgdG8gdGhlIHN0YXJ0IHZpZXcuXG4gICAqXG4gICAqIE90aGVyd2lzZSB0aGUgcGlja2VyIGRpc3BsYXlzIHRoZSBuZXh0IHZpZXcgd2l0aCB0aGUgbmV4dFxuICAgKiBzbWFsbGVzdCB0aW1lIGluY3JlbWVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqKi9cbiAgX29uRGF0ZUNsaWNrKGRhdGVCdXR0b246IERhdGVCdXR0b24pIHtcbiAgICBpZiAoZGF0ZUJ1dHRvbi5jbGFzc2VzWydkbC1hYmR0cC1kaXNhYmxlZCddKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IG5leHRWaWV3ID0gdGhpcy5fbmV4dFZpZXdbdGhpcy5fbW9kZWwudmlld05hbWVdO1xuXG4gICAgaWYgKCh0aGlzLm1pblZpZXcgfHwgJ21pbnV0ZScpID09PSB0aGlzLl9tb2RlbC52aWV3TmFtZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmZyb21NaWxsaXNlY29uZHMoZGF0ZUJ1dHRvbi52YWx1ZSk7XG4gICAgICBuZXh0VmlldyA9IHRoaXMuc3RhcnRWaWV3O1xuICAgIH1cblxuICAgIHRoaXMubW9kZWwgPSB0aGlzLl92aWV3VG9Nb2RlbFByb3ZpZGVyW25leHRWaWV3XS5nZXRNb2RlbChkYXRlQnV0dG9uLnZhbHVlLCB0aGlzLnZhbHVlT2YpO1xuXG4gICAgdGhpcy5vblRvdWNoKCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBjbGljayAoYW5kIGVudGVyICYgc3BhY2Uga2V5IGRvd24pIGV2ZW50cyBvbiB0aGUgbGVmdCBidXR0b24uXG4gICAqXG4gICAqIENoYW5nZXMgdGhlIGRpc3BsYXllZCB0aW1lIHJhbmdlIG9mIHRoZSBwaWNrZXIgdG8gdGhlIHByZXZpb3VzIHRpbWUgcmFuZ2UuXG4gICAqIEZvciBleGFtcGxlLCBpbiB5ZWFyIHZpZXcsIHRoZSBwcmV2aW91cyBkZWNhZGUgaXMgZGlzcGxheWVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICoqL1xuICBfb25MZWZ0Q2xpY2soKSB7XG4gICAgdGhpcy5tb2RlbCA9IHRoaXMuX3ZpZXdUb01vZGVsUHJvdmlkZXJbdGhpcy5fbW9kZWwudmlld05hbWVdLmdldE1vZGVsKHRoaXMuX21vZGVsLmxlZnRCdXR0b24udmFsdWUsIHRoaXMudmFsdWVPZik7XG4gICAgdGhpcy5vblRvdWNoKCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBjbGljayAoYW5kIGVudGVyICYgc3BhY2Uga2V5IGRvd24pIGV2ZW50cyBvbiB0aGUgdXAgYnV0dG9uLlxuICAgKlxuICAgKiBDaGFuZ2VzIHRoZSB2aWV3IG9mIHRoZSBwaWNrZXIgdG8gdGhlIG5leHQgbGFyZ2VzdCB0aW1lIGluY3JlbWVudC5cbiAgICogRm9yIGV4YW1wbGUsIGluIGRheSB2aWV3LCB0aGUgbmV4dCB2aWV3IGRpc3BsYXllZCB3aWxsIGJlIG1vbnRoIHZpZXcuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiovXG4gIF9vblVwQ2xpY2soKSB7XG4gICAgdGhpcy5tb2RlbCA9IHRoaXMuX3ZpZXdUb01vZGVsUHJvdmlkZXJbdGhpcy5fcHJldmlvdXNWaWV3W3RoaXMuX21vZGVsLnZpZXdOYW1lXV0uZ2V0TW9kZWwodGhpcy5fbW9kZWwudXBCdXR0b24udmFsdWUsIHRoaXMudmFsdWVPZik7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBjbGljayAoYW5kIGVudGVyICYgc3BhY2Uga2V5IGRvd24pIGV2ZW50cyBvbiB0aGUgcmlnaHQgYnV0dG9uLlxuICAgKlxuICAgKiBDaGFuZ2VzIHRoZSBkaXNwbGF5ZWQgdGltZSByYW5nZSBvZiB0aGUgcGlja2VyIHRvIHRoZSBuZXh0IHRpbWUgcmFuZ2UuXG4gICAqIEZvciBleGFtcGxlLCBpbiB5ZWFyIHZpZXcsIHRoZSBuZXh0IGRlY2FkZSBpcyBkaXNwbGF5ZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiovXG4gIF9vblJpZ2h0Q2xpY2soKSB7XG4gICAgdGhpcy5tb2RlbCA9IHRoaXMuX3ZpZXdUb01vZGVsUHJvdmlkZXJbdGhpcy5fbW9kZWwudmlld05hbWVdLmdldE1vZGVsKHRoaXMuX21vZGVsLnJpZ2h0QnV0dG9uLnZhbHVlLCB0aGlzLnZhbHVlT2YpO1xuICAgIHRoaXMub25Ub3VjaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdmFyaW91cyBrZXkgZG93biBldmVudHMgdG8gbW92ZSB0aGUgYGFjdGl2ZSBkYXRlYCBhcm91bmQgdGhlIGNhbGVuZGFyLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICoqL1xuICBfaGFuZGxlS2V5RG93bigkZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBrZXlDb2RlVG9Nb2RlbFByb3ZpZGVyTWV0aG9kWyRldmVudC5rZXldO1xuXG4gICAgY29uc29sZS5sb2coJGV2ZW50LCBmdW5jdGlvbk5hbWUpO1xuXG4gICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgY29uc3QgbW9kZWxQcm92aWRlciA9IHRoaXMuX3ZpZXdUb01vZGVsUHJvdmlkZXJbdGhpcy5fbW9kZWwudmlld05hbWVdO1xuICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsUHJvdmlkZXJbZnVuY3Rpb25OYW1lXSh0aGlzLl9tb2RlbC5hY3RpdmVEYXRlLCB0aGlzLnZhbHVlT2YpO1xuXG4gICAgICB0aGlzLmZvY3VzQWN0aXZlQ2VsbCgpO1xuICAgICAgLy8gUHJldmVudCB1bmV4cGVjdGVkIGRlZmF1bHQgYWN0aW9ucyBzdWNoIGFzIGZvcm0gc3VibWlzc2lvbi5cbiAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLnJlZ2lzdGVyT25DaGFuZ2UgdG8gcmVnaXN0ZXIgY2hhbmdlIGxpc3RlbmVycy5cbiAgICogQGludGVybmFsXG4gICAqKi9cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKHZhbHVlOiBEKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5fY2hhbmdlZC5wdXNoKGZuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLnJlZ2lzdGVyT25Ub3VjaGVkIHRvIHJlZ2lzdGVyIHRvdWNoIGxpc3RlbmVycy5cbiAgICogQGludGVybmFsXG4gICAqKi9cbiAgcmVnaXN0ZXJPblRvdWNoZWQoZm46ICgpID0+IHZvaWQpIHtcbiAgICB0aGlzLl90b3VjaGVkLnB1c2goZm4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Iud3JpdGVWYWx1ZSB0byBzdG9yZSB0aGUgdmFsdWUgZnJvbSB0aGUgbW9kZWwuXG4gICAqIEBpbnRlcm5hbFxuICAgKiovXG4gIHdyaXRlVmFsdWUodmFsdWU6IEQpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxufVxuXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBoYXNWYWx1ZSh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbHVlICE9PSBudWxsKTtcbn1cbiJdfQ==