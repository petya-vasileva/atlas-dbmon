/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright 2013-present Dale Lotts All Rights Reserved.
 * http://www.dalelotts.com
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
 */
import * as _moment from 'moment';
/**
 * Work around for moment namespace conflict when used with webpack and rollup.
 * See https://github.com/dherges/ng-packagr/issues/163
 *
 * Depending on whether rollup is used, moment needs to be imported differently.
 * Since Moment.js doesn't have a default export, we normally need to import using
 * the `* as`syntax.
 *
 * rollup creates a synthetic default module and we thus need to import it using
 * the `default as` syntax.
 *
 * \@internal
 *
 * @type {?}
 */
const moment = _moment;
/**
 * Default implementation for the `day` view.
 */
export class DlDayModelProvider {
    /**
     * Receives input changes detected by Angular.
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    onChanges(changes) {
    }
    /**
     * Returns the `day` model for the specified moment in `local` time with the
     * `active` day set to the first day of the month.
     *
     * The `day` model represents a month (42 days) as six rows with seven columns
     * and each cell representing one-day increments.
     *
     * The `day` always starts at midnight.
     *
     * Each cell represents a one-day increment at midnight.
     *
     * @param {?} milliseconds
     *  the moment in time from which the minute model will be created.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  the model representing the specified moment in time.
     */
    getModel(milliseconds, selectedMilliseconds) {
        /** @type {?} */
        const startOfMonth = moment(milliseconds).startOf('month');
        /** @type {?} */
        const endOfMonth = moment(milliseconds).endOf('month');
        /** @type {?} */
        const startOfView = moment(startOfMonth).subtract(Math.abs(startOfMonth.weekday()), 'days');
        /** @type {?} */
        const rowNumbers = [0, 1, 2, 3, 4, 5];
        /** @type {?} */
        const columnNumbers = [0, 1, 2, 3, 4, 5, 6];
        /** @type {?} */
        const previousMonth = moment(startOfMonth).subtract(1, 'month');
        /** @type {?} */
        const nextMonth = moment(startOfMonth).add(1, 'month');
        /** @type {?} */
        const activeValue = moment(milliseconds).startOf('day').valueOf();
        /** @type {?} */
        const selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
            ? selectedMilliseconds
            : moment(selectedMilliseconds).startOf('day').valueOf();
        /** @type {?} */
        const result = {
            viewName: 'day',
            viewLabel: startOfMonth.format('MMM YYYY'),
            activeDate: activeValue,
            leftButton: {
                value: previousMonth.valueOf(),
                ariaLabel: `Go to ${previousMonth.format('MMM YYYY')}`,
                classes: {},
            },
            upButton: {
                value: startOfMonth.valueOf(),
                ariaLabel: `Go to month view`,
                classes: {},
            },
            rightButton: {
                value: nextMonth.valueOf(),
                ariaLabel: `Go to ${nextMonth.format('MMM YYYY')}`,
                classes: {},
            },
            rowLabels: columnNumbers.map((/**
             * @param {?} column
             * @return {?}
             */
            (column) => moment().weekday(column).format('dd'))),
            rows: rowNumbers.map(rowOfDays)
        };
        result.leftButton.classes[`${result.leftButton.value}`] = true;
        result.rightButton.classes[`${result.rightButton.value}`] = true;
        return result;
        /**
         * @param {?} rowNumber
         * @return {?}
         */
        function rowOfDays(rowNumber) {
            /** @type {?} */
            const currentMoment = moment();
            /** @type {?} */
            const cells = columnNumbers.map((/**
             * @param {?} columnNumber
             * @return {?}
             */
            (columnNumber) => {
                /** @type {?} */
                const dayMoment = moment(startOfView).add((rowNumber * columnNumbers.length) + columnNumber, 'days');
                return {
                    display: dayMoment.format('D'),
                    ariaLabel: dayMoment.format('ll'),
                    value: dayMoment.valueOf(),
                    classes: {
                        'dl-abdtp-active': activeValue === dayMoment.valueOf(),
                        'dl-abdtp-future': dayMoment.isAfter(endOfMonth),
                        'dl-abdtp-past': dayMoment.isBefore(startOfMonth),
                        'dl-abdtp-selected': selectedValue === dayMoment.valueOf(),
                        'dl-abdtp-now': dayMoment.isSame(currentMoment, 'day'),
                    }
                };
            }));
            return { cells };
        }
    }
    /**
     * Move the active `day` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one row `down` from the specified moment in time.
     */
    goDown(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(7, 'days').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the active `day` one row `up` from the specified moment in time.
     *
     * Moving `up` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one row `up` from the specified moment in time.
     */
    goUp(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(7, 'days').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the `active` day one cell `left` in the current `day` view.
     *
     * Moving `left` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `day` model to the `left` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one cell to the `left` of the specified moment in time.
     */
    goLeft(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(1, 'day').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the `active` day one cell `right` in the current `day` view.
     *
     * Moving `right` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `day` model to the `right` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one cell to the `right` of the specified moment in time.
     */
    goRight(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(1, 'day').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the active `day` one month `down` from the specified moment in time.
     *
     * Paging `down` will result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`. As a result, the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one month `down` from the specified moment in time.
     */
    pageDown(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(1, 'month').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the active `day` one month `up` from the specified moment in time.
     *
     * Paging `up` will result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`. As a result, the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model page `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one month `up` from the specified moment in time.
     */
    pageUp(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(1, 'month').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the `active` `day` to the last day of the month.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the last day of the month will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the last cell in the view as the active `day`.
     */
    goEnd(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds)
            .endOf('month').startOf('day').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the `active` `day` to the first day of the month.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the first day of the month will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the first cell in the view as the active `day`.
     */
    goHome(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).startOf('month').valueOf(), selectedMilliseconds);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGwtbW9kZWwtcHJvdmlkZXItZGF5LmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvIiwic291cmNlcyI6WyJkbC1kYXRlLXRpbWUtcGlja2VyL2RsLW1vZGVsLXByb3ZpZGVyLWRheS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFVQSxPQUFPLEtBQUssT0FBTyxNQUFNLFFBQVEsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztNQWlCNUIsTUFBTSxHQUFHLE9BQU87Ozs7QUFLdEIsTUFBTSxPQUFPLGtCQUFrQjs7Ozs7Ozs7SUFRN0IsU0FBUyxDQUFDLE9BQXNCO0lBQ2hDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFvQkQsUUFBUSxDQUFDLFlBQW9CLEVBQUUsb0JBQTRCOztjQUVuRCxZQUFZLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUM7O2NBQ3BELFVBQVUsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQzs7Y0FDaEQsV0FBVyxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUM7O2NBRXJGLFVBQVUsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDOztjQUMvQixhQUFhLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7O2NBRXJDLGFBQWEsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUM7O2NBQ3pELFNBQVMsR0FBRyxNQUFNLENBQUMsWUFBWSxD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QUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztJQUNqRyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7SUFnQkQsTUFBTSxDQUFDLGdCQUF3QixFQUFFLG9CQUE0QjtRQUMzRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO0lBQ3RHLENBQUM7Ozs7Ozs7Ozs7Ozs7O0lBZ0JELEtBQUssQ0FBQyxnQkFBd0IsRUFBRSxvQkFBNEI7UUFDMUQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQzthQUMxQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLG9CQUFvQixDQUFDLENBQUM7SUFDcEUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7SUFlRCxNQUFNLENBQUMsZ0JBQXdCLEVBQUUsb0JBQTRCO1FBQzNELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztJQUNsRyxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50IERhbGUgTG90dHMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuZGFsZWxvdHRzLmNvbVxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9kYWxlbG90dHMvYW5ndWxhci1ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5cbmltcG9ydCB7U2ltcGxlQ2hhbmdlc30gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgKiBhcyBfbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQge0RsRGF0ZVRpbWVQaWNrZXJNb2RlbH0gZnJvbSAnLi9kbC1kYXRlLXRpbWUtcGlja2VyLW1vZGVsJztcbmltcG9ydCB7RGxNb2RlbFByb3ZpZGVyfSBmcm9tICcuL2RsLW1vZGVsLXByb3ZpZGVyJztcblxuLyoqXG4gKiBXb3JrIGFyb3VuZCBmb3IgbW9tZW50IG5hbWVzcGFjZSBjb25mbGljdCB3aGVuIHVzZWQgd2l0aCB3ZWJwYWNrIGFuZCByb2xsdXAuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2RoZXJnZXMvbmctcGFja2Fnci9pc3N1ZXMvMTYzXG4gKlxuICogRGVwZW5kaW5nIG9uIHdoZXRoZXIgcm9sbHVwIGlzIHVzZWQsIG1vbWVudCBuZWVkcyB0byBiZSBpbXBvcnRlZCBkaWZmZXJlbnRseS5cbiAqIFNpbmNlIE1vbWVudC5qcyBkb2Vzbid0IGhhdmUgYSBkZWZhdWx0IGV4cG9ydCwgd2Ugbm9ybWFsbHkgbmVlZCB0byBpbXBvcnQgdXNpbmdcbiAqIHRoZSBgKiBhc2BzeW50YXguXG4gKlxuICogcm9sbHVwIGNyZWF0ZXMgYSBzeW50aGV0aWMgZGVmYXVsdCBtb2R1bGUgYW5kIHdlIHRodXMgbmVlZCB0byBpbXBvcnQgaXQgdXNpbmdcbiAqIHRoZSBgZGVmYXVsdCBhc2Agc3ludGF4LlxuICpcbiAqIEBpbnRlcm5hbFxuICoqL1xuY29uc3QgbW9tZW50ID0gX21vbWVudDtcblxuLyoqXG4gKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciB0aGUgYGRheWAgdmlldy5cbiAqL1xuZXhwb3J0IGNsYXNzIERsRGF5TW9kZWxQcm92aWRlciBpbXBsZW1lbnRzIERsTW9kZWxQcm92aWRlciB7XG5cbiAgLyoqXG4gICAqIFJlY2VpdmVzIGlucHV0IGNoYW5nZXMgZGV0ZWN0ZWQgYnkgQW5ndWxhci5cbiAgICpcbiAgICogQHBhcmFtIGNoYW5nZXNcbiAgICogIHRoZSBpbnB1dCBjaGFuZ2VzIGRldGVjdGVkIGJ5IEFuZ3VsYXIuXG4gICAqL1xuICBvbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBkYXlgIG1vZGVsIGZvciB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiBgbG9jYWxgIHRpbWUgd2l0aCB0aGVcbiAgICogYGFjdGl2ZWAgZGF5IHNldCB0byB0aGUgZmlyc3QgZGF5IG9mIHRoZSBtb250aC5cbiAgICpcbiAgICogVGhlIGBkYXlgIG1vZGVsIHJlcHJlc2VudHMgYSBtb250aCAoNDIgZGF5cykgYXMgc2l4IHJvd3Mgd2l0aCBzZXZlbiBjb2x1bW5zXG4gICAqIGFuZCBlYWNoIGNlbGwgcmVwcmVzZW50aW5nIG9uZS1kYXkgaW5jcmVtZW50cy5cbiAgICpcbiAgICogVGhlIGBkYXlgIGFsd2F5cyBzdGFydHMgYXQgbWlkbmlnaHQuXG4gICAqXG4gICAqIEVhY2ggY2VsbCByZXByZXNlbnRzIGEgb25lLWRheSBpbmNyZW1lbnQgYXQgbWlkbmlnaHQuXG4gICAqXG4gICAqIEBwYXJhbSBtaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBtaW51dGUgbW9kZWwgd2lsbCBiZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgdGhlIG1vZGVsIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKi9cbiAgZ2V0TW9kZWwobWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuXG4gICAgY29uc3Qgc3RhcnRPZk1vbnRoID0gbW9tZW50KG1pbGxpc2Vjb25kcykuc3RhcnRPZignbW9udGgnKTtcbiAgICBjb25zdCBlbmRPZk1vbnRoID0gbW9tZW50KG1pbGxpc2Vjb25kcykuZW5kT2YoJ21vbnRoJyk7XG4gICAgY29uc3Qgc3RhcnRPZlZpZXcgPSBtb21lbnQoc3RhcnRPZk1vbnRoKS5zdWJ0cmFjdChNYXRoLmFicyhzdGFydE9mTW9udGgud2Vla2RheSgpKSwgJ2RheXMnKTtcblxuICAgIGNvbnN0IHJvd051bWJlcnMgPSBbMCwgMSwgMiwgMywgNCwgNV07XG4gICAgY29uc3QgY29sdW1uTnVtYmVycyA9IFswLCAxLCAyLCAzLCA0LCA1LCA2XTtcblxuICAgIGNvbnN0IHByZXZpb3VzTW9udGggPSBtb21lbnQoc3RhcnRPZk1vbnRoKS5zdWJ0cmFjdCgxLCAnbW9udGgnKTtcbiAgICBjb25zdCBuZXh0TW9udGggPSBtb21lbnQoc3RhcnRPZk1vbnRoKS5hZGQoMSwgJ21vbnRoJyk7XG4gICAgY29uc3QgYWN0aXZlVmFsdWUgPSBtb21lbnQobWlsbGlzZWNvbmRzKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWRWYWx1ZSA9IHNlbGVjdGVkTWlsbGlzZWNvbmRzID09PSBudWxsIHx8IHNlbGVjdGVkTWlsbGlzZWNvbmRzID09PSB1bmRlZmluZWRcbiAgICAgID8gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICAgIDogbW9tZW50KHNlbGVjdGVkTWlsbGlzZWNvbmRzKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICBjb25zdCByZXN1bHQ6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCA9IHtcbiAgICAgIHZpZXdOYW1lOiAnZGF5JyxcbiAgICAgIHZpZXdMYWJlbDogc3RhcnRPZk1vbnRoLmZvcm1hdCgnTU1NIFlZWVknKSxcbiAgICAgIGFjdGl2ZURhdGU6IGFjdGl2ZVZhbHVlLFxuICAgICAgbGVmdEJ1dHRvbjoge1xuICAgICAgICB2YWx1ZTogcHJldmlvdXNNb250aC52YWx1ZU9mKCksXG4gICAgICAgIGFyaWFMYWJlbDogYEdvIHRvICR7cHJldmlvdXNNb250aC5mb3JtYXQoJ01NTSBZWVlZJyl9YCxcbiAgICAgICAgY2xhc3Nlczoge30sXG4gICAgICB9LFxuICAgICAgdXBCdXR0b246IHtcbiAgICAgICAgdmFsdWU6IHN0YXJ0T2ZNb250aC52YWx1ZU9mKCksXG4gICAgICAgIGFyaWFMYWJlbDogYEdvIHRvIG1vbnRoIHZpZXdgLFxuICAgICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIH0sXG4gICAgICByaWdodEJ1dHRvbjoge1xuICAgICAgICB2YWx1ZTogbmV4dE1vbnRoLnZhbHVlT2YoKSxcbiAgICAgICAgYXJpYUxhYmVsOiBgR28gdG8gJHtuZXh0TW9udGguZm9ybWF0KCdNTU0gWVlZWScpfWAsXG4gICAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgfSxcbiAgICAgIHJvd0xhYmVsczogY29sdW1uTnVtYmVycy5tYXAoKGNvbHVtbikgPT4gbW9tZW50KCkud2Vla2RheShjb2x1bW4pLmZvcm1hdCgnZGQnKSksXG4gICAgICByb3dzOiByb3dOdW1iZXJzLm1hcChyb3dPZkRheXMpXG4gICAgfTtcblxuICAgIHJlc3VsdC5sZWZ0QnV0dG9uLmNsYXNzZXNbYCR7cmVzdWx0LmxlZnRCdXR0b24udmFsdWV9YF0gPSB0cnVlO1xuICAgIHJlc3VsdC5yaWdodEJ1dHRvbi5jbGFzc2VzW2Ake3Jlc3VsdC5yaWdodEJ1dHRvbi52YWx1ZX1gXSA9IHRydWU7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgZnVuY3Rpb24gcm93T2ZEYXlzKHJvd051bWJlcikge1xuICAgICAgY29uc3QgY3VycmVudE1vbWVudCA9IG1vbWVudCgpO1xuICAgICAgY29uc3QgY2VsbHMgPSBjb2x1bW5OdW1iZXJzLm1hcCgoY29sdW1uTnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGRheU1vbWVudCA9IG1vbWVudChzdGFydE9mVmlldykuYWRkKChyb3dOdW1iZXIgKiBjb2x1bW5OdW1iZXJzLmxlbmd0aCkgKyBjb2x1bW5OdW1iZXIsICdkYXlzJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlzcGxheTogZGF5TW9tZW50LmZvcm1hdCgnRCcpLFxuICAgICAgICAgIGFyaWFMYWJlbDogZGF5TW9tZW50LmZvcm1hdCgnbGwnKSxcbiAgICAgICAgICB2YWx1ZTogZGF5TW9tZW50LnZhbHVlT2YoKSxcbiAgICAgICAgICBjbGFzc2VzOiB7XG4gICAgICAgICAgICAnZGwtYWJkdHAtYWN0aXZlJzogYWN0aXZlVmFsdWUgPT09IGRheU1vbWVudC52YWx1ZU9mKCksXG4gICAgICAgICAgICAnZGwtYWJkdHAtZnV0dXJlJzogZGF5TW9tZW50LmlzQWZ0ZXIoZW5kT2ZNb250aCksXG4gICAgICAgICAgICAnZGwtYWJkdHAtcGFzdCc6IGRheU1vbWVudC5pc0JlZm9yZShzdGFydE9mTW9udGgpLFxuICAgICAgICAgICAgJ2RsLWFiZHRwLXNlbGVjdGVkJzogc2VsZWN0ZWRWYWx1ZSA9PT0gZGF5TW9tZW50LnZhbHVlT2YoKSxcbiAgICAgICAgICAgICdkbC1hYmR0cC1ub3cnOiBkYXlNb21lbnQuaXNTYW1lKGN1cnJlbnRNb21lbnQsICdkYXknKSxcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7Y2VsbHN9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBhY3RpdmUgYGRheWAgb25lIHJvdyBgZG93bmAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKlxuICAgKiBNb3ZpbmcgYGRvd25gIGNhbiByZXN1bHQgaW4gdGhlIGBhY3RpdmVgIGRheSBiZWluZyBwYXJ0IG9mIGEgZGlmZmVyZW50IG1vbnRoIHRoYW5cbiAgICogdGhlIHNwZWNpZmllZCBgZnJvbU1pbGxpc2Vjb25kc2AsIGluIHRoaXMgY2FzZSB0aGUgbW9udGggcmVwcmVzZW50ZWQgYnkgdGhlIG1vZGVsXG4gICAqIHdpbGwgY2hhbmdlIHRvIHNob3cgdGhlIGNvcnJlY3QgaG91ci5cbiAgICpcbiAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBuZXh0IGBkYXlgIG1vZGVsIGBkb3duYCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgbW9kZWwgY29udGFpbmluZyBhbiBgYWN0aXZlYCBgZGF5YCBvbmUgcm93IGBkb3duYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqL1xuICBnb0Rvd24oZnJvbU1pbGxpc2Vjb25kczogbnVtYmVyLCBzZWxlY3RlZE1pbGxpc2Vjb25kczogbnVtYmVyKTogRGxEYXRlVGltZVBpY2tlck1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNb2RlbChtb21lbnQoZnJvbU1pbGxpc2Vjb25kcykuYWRkKDcsICdkYXlzJykudmFsdWVPZigpLCBzZWxlY3RlZE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgYWN0aXZlIGBkYXlgIG9uZSByb3cgYHVwYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqXG4gICAqIE1vdmluZyBgdXBgIGNhbiByZXN1bHQgaW4gdGhlIGBhY3RpdmVgIGRheSBiZWluZyBwYXJ0IG9mIGEgZGlmZmVyZW50IG1vbnRoIHRoYW5cbiAgICogdGhlIHNwZWNpZmllZCBgZnJvbU1pbGxpc2Vjb25kc2AsIGluIHRoaXMgY2FzZSB0aGUgbW9udGggcmVwcmVzZW50ZWQgYnkgdGhlIG1vZGVsXG4gICAqIHdpbGwgY2hhbmdlIHRvIHNob3cgdGhlIGNvcnJlY3QgaG91ci5cbiAgICpcbiAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBuZXh0IGBkYXlgIG1vZGVsIGB1cGAgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIG1vZGVsIGNvbnRhaW5pbmcgYW4gYGFjdGl2ZWAgYGRheWAgb25lIHJvdyBgdXBgIGZyb20gdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICovXG4gIGdvVXAoZnJvbU1pbGxpc2Vjb25kczogbnVtYmVyLCBzZWxlY3RlZE1pbGxpc2Vjb25kczogbnVtYmVyKTogRGxEYXRlVGltZVBpY2tlck1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNb2RlbChtb21lbnQoZnJvbU1pbGxpc2Vjb25kcykuc3VidHJhY3QoNywgJ2RheXMnKS52YWx1ZU9mKCksIHNlbGVjdGVkTWlsbGlzZWNvbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBgYWN0aXZlYCBkYXkgb25lIGNlbGwgYGxlZnRgIGluIHRoZSBjdXJyZW50IGBkYXlgIHZpZXcuXG4gICAqXG4gICAqIE1vdmluZyBgbGVmdGAgY2FuIHJlc3VsdCBpbiB0aGUgYGFjdGl2ZWAgZGF5IGJlaW5nIHBhcnQgb2YgYSBkaWZmZXJlbnQgbW9udGggdGhhblxuICAgKiB0aGUgc3BlY2lmaWVkIGBmcm9tTWlsbGlzZWNvbmRzYCwgaW4gdGhpcyBjYXNlIHRoZSBtb250aCByZXByZXNlbnRlZCBieSB0aGUgbW9kZWxcbiAgICogd2lsbCBjaGFuZ2UgdG8gc2hvdyB0aGUgY29ycmVjdCB5ZWFyLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIGBkYXlgIG1vZGVsIHRvIHRoZSBgbGVmdGAgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIG1vZGVsIGNvbnRhaW5pbmcgYW4gYGFjdGl2ZWAgYGRheWAgb25lIGNlbGwgdG8gdGhlIGBsZWZ0YCBvZiB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKi9cbiAgZ29MZWZ0KGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwobW9tZW50KGZyb21NaWxsaXNlY29uZHMpLnN1YnRyYWN0KDEsICdkYXknKS52YWx1ZU9mKCksIHNlbGVjdGVkTWlsbGlzZWNvbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBgYWN0aXZlYCBkYXkgb25lIGNlbGwgYHJpZ2h0YCBpbiB0aGUgY3VycmVudCBgZGF5YCB2aWV3LlxuICAgKlxuICAgKiBNb3ZpbmcgYHJpZ2h0YCBjYW4gcmVzdWx0IGluIHRoZSBgYWN0aXZlYCBkYXkgYmVpbmcgcGFydCBvZiBhIGRpZmZlcmVudCBtb250aCB0aGFuXG4gICAqIHRoZSBzcGVjaWZpZWQgYGZyb21NaWxsaXNlY29uZHNgLCBpbiB0aGlzIGNhc2UgdGhlIG1vbnRoIHJlcHJlc2VudGVkIGJ5IHRoZSBtb2RlbFxuICAgKiB3aWxsIGNoYW5nZSB0byBzaG93IHRoZSBjb3JyZWN0IHllYXIuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgYGRheWAgbW9kZWwgdG8gdGhlIGByaWdodGAgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIG1vZGVsIGNvbnRhaW5pbmcgYW4gYGFjdGl2ZWAgYGRheWAgb25lIGNlbGwgdG8gdGhlIGByaWdodGAgb2YgdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICovXG4gIGdvUmlnaHQoZnJvbU1pbGxpc2Vjb25kczogbnVtYmVyLCBzZWxlY3RlZE1pbGxpc2Vjb25kczogbnVtYmVyKTogRGxEYXRlVGltZVBpY2tlck1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNb2RlbChtb21lbnQoZnJvbU1pbGxpc2Vjb25kcykuYWRkKDEsICdkYXknKS52YWx1ZU9mKCksIHNlbGVjdGVkTWlsbGlzZWNvbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBhY3RpdmUgYGRheWAgb25lIG1vbnRoIGBkb3duYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqXG4gICAqIFBhZ2luZyBgZG93bmAgd2lsbCByZXN1bHQgaW4gdGhlIGBhY3RpdmVgIGRheSBiZWluZyBwYXJ0IG9mIGEgZGlmZmVyZW50IG1vbnRoIHRoYW5cbiAgICogdGhlIHNwZWNpZmllZCBgZnJvbU1pbGxpc2Vjb25kc2AuIEFzIGEgcmVzdWx0LCB0aGUgbW9udGggcmVwcmVzZW50ZWQgYnkgdGhlIG1vZGVsXG4gICAqIHdpbGwgY2hhbmdlIHRvIHNob3cgdGhlIGNvcnJlY3QgeWVhci5cbiAgICpcbiAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBuZXh0IGBkYXlgIG1vZGVsIHBhZ2UgYGRvd25gIHdpbGwgYmUgY29uc3RydWN0ZWQuXG4gICAqIEBwYXJhbSBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBwaWNrZXIuXG4gICAqIEByZXR1cm5zXG4gICAqICBtb2RlbCBjb250YWluaW5nIGFuIGBhY3RpdmVgIGBkYXlgIG9uZSBtb250aCBgZG93bmAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKi9cbiAgcGFnZURvd24oZnJvbU1pbGxpc2Vjb25kczogbnVtYmVyLCBzZWxlY3RlZE1pbGxpc2Vjb25kczogbnVtYmVyKTogRGxEYXRlVGltZVBpY2tlck1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNb2RlbChtb21lbnQoZnJvbU1pbGxpc2Vjb25kcykuYWRkKDEsICdtb250aCcpLnZhbHVlT2YoKSwgc2VsZWN0ZWRNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGFjdGl2ZSBgZGF5YCBvbmUgbW9udGggYHVwYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqXG4gICAqIFBhZ2luZyBgdXBgIHdpbGwgcmVzdWx0IGluIHRoZSBgYWN0aXZlYCBkYXkgYmVpbmcgcGFydCBvZiBhIGRpZmZlcmVudCBtb250aCB0aGFuXG4gICAqIHRoZSBzcGVjaWZpZWQgYGZyb21NaWxsaXNlY29uZHNgLiBBcyBhIHJlc3VsdCwgdGhlIG1vbnRoIHJlcHJlc2VudGVkIGJ5IHRoZSBtb2RlbFxuICAgKiB3aWxsIGNoYW5nZSB0byBzaG93IHRoZSBjb3JyZWN0IHllYXIuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgbmV4dCBgZGF5YCBtb2RlbCBwYWdlIGB1cGAgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIG1vZGVsIGNvbnRhaW5pbmcgYW4gYGFjdGl2ZWAgYGRheWAgb25lIG1vbnRoIGB1cGAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKi9cbiAgcGFnZVVwKGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwobW9tZW50KGZyb21NaWxsaXNlY29uZHMpLnN1YnRyYWN0KDEsICdtb250aCcpLnZhbHVlT2YoKSwgc2VsZWN0ZWRNaWxsaXNlY29uZHMpO1xuICB9XG5cblxuICAvKipcbiAgICogTW92ZSB0aGUgYGFjdGl2ZWAgYGRheWAgdG8gdGhlIGxhc3QgZGF5IG9mIHRoZSBtb250aC5cbiAgICpcbiAgICogVGhlIHZpZXcgb3IgdGltZSByYW5nZSB3aWxsIG5vdCBjaGFuZ2UgdW5sZXNzIHRoZSBgZnJvbU1pbGxpc2Vjb25kc2AgdmFsdWVcbiAgICogaXMgaW4gYSBkaWZmZXJlbnQgZGF5IHRoYW4gdGhlIGRpc3BsYXllZCBkZWNhZGUuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgbGFzdCBkYXkgb2YgdGhlIG1vbnRoIHdpbGwgYmUgY2FsY3VsYXRlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIGEgbW9kZWwgd2l0aCB0aGUgbGFzdCBjZWxsIGluIHRoZSB2aWV3IGFzIHRoZSBhY3RpdmUgYGRheWAuXG4gICAqL1xuICBnb0VuZChmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLmdldE1vZGVsKG1vbWVudChmcm9tTWlsbGlzZWNvbmRzKVxuICAgICAgLmVuZE9mKCdtb250aCcpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKSwgc2VsZWN0ZWRNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGBhY3RpdmVgIGBkYXlgIHRvIHRoZSBmaXJzdCBkYXkgb2YgdGhlIG1vbnRoLlxuICAgKlxuICAgKiBUaGUgdmlldyBvciB0aW1lIHJhbmdlIHdpbGwgbm90IGNoYW5nZSB1bmxlc3MgdGhlIGBmcm9tTWlsbGlzZWNvbmRzYCB2YWx1ZVxuICAgKiBpcyBpbiBhIGRpZmZlcmVudCBkYXkgdGhhbiB0aGUgZGlzcGxheWVkIGRlY2FkZS5cbiAgICpcbiAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBmaXJzdCBkYXkgb2YgdGhlIG1vbnRoIHdpbGwgYmUgY2FsY3VsYXRlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIGEgbW9kZWwgd2l0aCB0aGUgZmlyc3QgY2VsbCBpbiB0aGUgdmlldyBhcyB0aGUgYWN0aXZlIGBkYXlgLlxuICAgKi9cbiAgZ29Ib21lKGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwobW9tZW50KGZyb21NaWxsaXNlY29uZHMpLnN0YXJ0T2YoJ21vbnRoJykudmFsdWVPZigpLCBzZWxlY3RlZE1pbGxpc2Vjb25kcyk7XG4gIH1cbn1cbiJdfQ==