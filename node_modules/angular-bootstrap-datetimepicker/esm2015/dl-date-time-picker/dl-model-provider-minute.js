/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright 2013-present Dale Lotts All Rights Reserved.
 * http://www.dalelotts.com
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
 */
import * as _moment from 'moment';
/**
 * Work around for moment namespace conflict when used with webpack and rollup.
 * See https://github.com/dherges/ng-packagr/issues/163
 *
 * Depending on whether rollup is used, moment needs to be imported differently.
 * Since Moment.js doesn't have a default export, we normally need to import using
 * the `* as`syntax.
 *
 * rollup creates a synthetic default module and we thus need to import it using
 * the `default as` syntax.
 *
 * \@internal
 *
 * @type {?}
 */
const moment = _moment;
/**
 * Default implementation for the `minute` view.
 */
export class DlMinuteModelProvider {
    constructor() {
        this.step = 5;
    }
    /**
     * Receives `minuteStep` configuration changes detected by Angular.
     *
     * Changes where the value has not changed are ignored.
     *
     * Setting `minuteStep` to `null` or `undefined` will result in a
     * minuteStep of `5`.
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    onChanges(changes) {
        /** @type {?} */
        const minuteStepChange = changes['minuteStep'];
        if (minuteStepChange
            && (minuteStepChange.previousValue !== minuteStepChange.currentValue)) {
            this.step = minuteStepChange.currentValue;
            if (this.step === null || this.step === undefined) {
                this.step = 5;
            }
        }
    }
    /**
     * Returns the `minute` model for the specified moment in `local` time with the
     * `active` minute set to the beginning of the hour.
     *
     * The `minute` model represents an hour (60 minutes) as three rows with four columns
     * and each cell representing 5-minute increments.
     *
     * The hour always starts at midnight.
     *
     * Each cell represents a 5-minute increment starting at midnight.
     *
     * The `active` minute will be the 5-minute increments less than or equal to the specified milliseconds.
     *
     * @param {?} milliseconds
     *  the moment in time from which the minute model will be created.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  the model representing the specified moment in time.
     */
    getModel(milliseconds, selectedMilliseconds) {
        /** @type {?} */
        const startDate = moment(milliseconds).startOf('hour');
        /** @type {?} */
        const currentMilliseconds = moment().valueOf();
        /** @type {?} */
        const minuteSteps = new Array(Math.ceil(60 / this.step)).fill(0).map((/**
         * @param {?} value
         * @param {?} index
         * @return {?}
         */
        (value, index) => index * this.step));
        /** @type {?} */
        const minuteValues = minuteSteps.map((/**
         * @param {?} minutesToAdd
         * @return {?}
         */
        (minutesToAdd) => moment(startDate).add(minutesToAdd, 'minutes').valueOf()));
        /** @type {?} */
        const activeValue = moment(minuteValues.filter((/**
         * @param {?} value
         * @return {?}
         */
        (value) => value <= milliseconds)).pop()).valueOf();
        /** @type {?} */
        const nowValue = currentMilliseconds >= startDate.valueOf() && currentMilliseconds <= moment(startDate).endOf('hour').valueOf()
            ? moment(minuteValues.filter((/**
             * @param {?} value
             * @return {?}
             */
            (value) => value <= currentMilliseconds)).pop()).valueOf()
            : null;
        /** @type {?} */
        const previousHour = moment(startDate).subtract(1, 'hour');
        /** @type {?} */
        const nextHour = moment(startDate).add(1, 'hour');
        /** @type {?} */
        const selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
            ? selectedMilliseconds
            : moment(minuteValues.filter((/**
             * @param {?} value
             * @return {?}
             */
            (value) => value <= selectedMilliseconds)).pop()).valueOf();
        /** @type {?} */
        const rows = new Array(Math.ceil(minuteSteps.length / 4))
            .fill(0)
            .map((/**
         * @param {?} value
         * @param {?} index
         * @return {?}
         */
        (value, index) => index))
            .map((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            return { cells: minuteSteps.slice((value * 4), (value * 4) + 4).map(rowOfMinutes) };
        }));
        /** @type {?} */
        const result = {
            viewName: 'minute',
            viewLabel: startDate.format('lll'),
            activeDate: activeValue,
            leftButton: {
                value: previousHour.valueOf(),
                ariaLabel: `Go to ${previousHour.format('lll')}`,
                classes: {},
            },
            upButton: {
                value: startDate.valueOf(),
                ariaLabel: `Go to ${startDate.format('ll')}`,
                classes: {},
            },
            rightButton: {
                value: nextHour.valueOf(),
                ariaLabel: `Go to ${nextHour.format('lll')}`,
                classes: {},
            },
            rows
        };
        result.leftButton.classes[`${result.leftButton.value}`] = true;
        result.rightButton.classes[`${result.rightButton.value}`] = true;
        return result;
        /**
         * @param {?} stepMinutes
         * @return {?}
         */
        function rowOfMinutes(stepMinutes) {
            /** @type {?} */
            const minuteMoment = moment(startDate).add(stepMinutes, 'minutes');
            return {
                display: minuteMoment.format('LT'),
                ariaLabel: minuteMoment.format('LLL'),
                value: minuteMoment.valueOf(),
                classes: {
                    'dl-abdtp-active': activeValue === minuteMoment.valueOf(),
                    'dl-abdtp-selected': selectedValue === minuteMoment.valueOf(),
                    'dl-abdtp-now': nowValue === minuteMoment.valueOf(),
                }
            };
        }
    }
    /**
     * Move the active `minute` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` minute being part of a different hour than
     * the specified `fromMilliseconds`, in this case the hour represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `minute` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `minute` one row `down` from the specified moment in time.
     */
    goDown(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(this.step * 4, 'minutes').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the active `minute` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` minute being part of a different hour than
     * the specified `fromMilliseconds`, in this case the hour represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `minute` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `minute` one row `down` from the specified moment in time.
     */
    goUp(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(this.step * 4, 'minutes').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the `active` date one cell to `left` in the current `minute` view.
     *
     * Moving `left` can result in the `active` hour being part of a different hour than
     * the specified `fromMilliseconds`, in this case the hour represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `minute` model to the `left` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `minute` one cell to the `left` of the specified moment in time.
     */
    goLeft(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(this.step, 'minutes').valueOf(), selectedMilliseconds);
    }
    /**
     * Move `active` minute one cell to `right` in the current `minute` view.
     *
     * Moving `right` can result in the `active` hour being part of a different hour than
     * the specified `fromMilliseconds`, in this case the hour represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `minute` model to the `right` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `minute` one cell to the `right` of the specified moment in time.
     */
    goRight(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(this.step, 'minutes').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the active `minute` one hour `down` from the specified moment in time.
     *
     * The `active` minute will be `one (1) hour after` the specified milliseconds.
     * This moves the `active` date one `page` `down` from the current `minute` view.
     *
     * The next cell `page-down` will be in a different hour than the currently
     * displayed view and the model time range will include the new active cell.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `month` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one year `down` from the specified moment in time.
     */
    pageDown(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(1, 'hour').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the active `minute` one hour `up` from the specified moment in time.
     *
     * The `active` minute will be `one (1) hour before` the specified milliseconds.
     * This moves the `active` date one `page` `down` from the current `minute` view.
     *
     * The next cell `page-up` will be in a different hour than the currently
     * displayed view and the model time range will include the new active cell.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `month` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one year `down` from the specified moment in time.
     */
    pageUp(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(1, 'hour').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the `active` `minute` to the last cell of the current hour.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different hour than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the last cell will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the last cell in the view as the active `minute`.
     */
    goEnd(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds)
            .endOf('hour')
            .valueOf(), selectedMilliseconds);
    }
    /**
     * Move the `active` `minute` to the first cell of the current hour.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different hour than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the first cell will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the first cell in the view as the active `minute`.
     */
    goHome(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).startOf('hour').valueOf(), selectedMilliseconds);
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    DlMinuteModelProvider.prototype.step;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGwtbW9kZWwtcHJvdmlkZXItbWludXRlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvIiwic291cmNlcyI6WyJkbC1kYXRlLXRpbWUtcGlja2VyL2RsLW1vZGVsLXByb3ZpZGVyLW1pbnV0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFVQSxPQUFPLEtBQUssT0FBTyxNQUFNLFFBQVEsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztNQWlCNUIsTUFBTSxHQUFHLE9BQU87Ozs7QUFLdEIsTUFBTSxPQUFPLHFCQUFxQjtJQUFsQztRQUVVLFNBQUksR0FBRyxDQUFDLENBQUM7SUE2UW5CLENBQUM7Ozs7Ozs7Ozs7Ozs7SUEvUEMsU0FBUyxDQUFDLE9BQXNCOztjQUV4QixnQkFBZ0IsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDO1FBRTlDLElBQUksZ0JBQWdCO2VBQ2YsQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLEtBQUssZ0JBQWdCLENBQUMsWUFBWSxDQUFDLEVBQ3JFO1lBQ0EsSUFBSSxDQUFDLElBQUksR0FBRyxnQkFBZ0IsQ0FBQyxZQUFZLENBQUM7WUFDMUMsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLFNBQVMsRUFBRTtnQkFDakQsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7YUFDZjtTQUNGO0lBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBdUJELFFBQVEsQ0FBQyxZQUFvQixFQUFFLG9CQUE0Qjs7Y0FDbkQsU0FBUyxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDOztjQUNoRCxtQkFBbUIsR0FBRyxNQUFNLEVBQUUsQ0FBQyxPQUFPLEVBQUU7O2NBRXhDLFdBQVcsR0FBRyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMs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QixFQUFFLG9CQUE0QjtRQUMzRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO0lBQ3JHLENBQUM7Ozs7Ozs7Ozs7Ozs7O0lBZUQsS0FBSyxDQUFDLGdCQUF3QixFQUFFLG9CQUE0QjtRQUMxRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDO2FBQzFDLEtBQUssQ0FBQyxNQUFNLENBQUM7YUFDYixPQUFPLEVBQUUsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7Ozs7Ozs7Ozs7Ozs7O0lBZUQsTUFBTSxDQUFDLGdCQUF3QixFQUFFLG9CQUE0QjtRQUMzRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLG9CQUFvQixDQUFDLENBQUM7SUFDakcsQ0FBQztDQUNGOzs7Ozs7SUE3UUMscUNBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCBEYWxlIExvdHRzIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmRhbGVsb3R0cy5jb21cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2dpdGh1Yi5jb20vZGFsZWxvdHRzL2FuZ3VsYXItYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG5pbXBvcnQge1NpbXBsZUNoYW5nZXN9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgX21vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHtEbERhdGVUaW1lUGlja2VyTW9kZWx9IGZyb20gJy4vZGwtZGF0ZS10aW1lLXBpY2tlci1tb2RlbCc7XG5pbXBvcnQge0RsTW9kZWxQcm92aWRlcn0gZnJvbSAnLi9kbC1tb2RlbC1wcm92aWRlcic7XG5cbi8qKlxuICogV29yayBhcm91bmQgZm9yIG1vbWVudCBuYW1lc3BhY2UgY29uZmxpY3Qgd2hlbiB1c2VkIHdpdGggd2VicGFjayBhbmQgcm9sbHVwLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kaGVyZ2VzL25nLXBhY2thZ3IvaXNzdWVzLzE2M1xuICpcbiAqIERlcGVuZGluZyBvbiB3aGV0aGVyIHJvbGx1cCBpcyB1c2VkLCBtb21lbnQgbmVlZHMgdG8gYmUgaW1wb3J0ZWQgZGlmZmVyZW50bHkuXG4gKiBTaW5jZSBNb21lbnQuanMgZG9lc24ndCBoYXZlIGEgZGVmYXVsdCBleHBvcnQsIHdlIG5vcm1hbGx5IG5lZWQgdG8gaW1wb3J0IHVzaW5nXG4gKiB0aGUgYCogYXNgc3ludGF4LlxuICpcbiAqIHJvbGx1cCBjcmVhdGVzIGEgc3ludGhldGljIGRlZmF1bHQgbW9kdWxlIGFuZCB3ZSB0aHVzIG5lZWQgdG8gaW1wb3J0IGl0IHVzaW5nXG4gKiB0aGUgYGRlZmF1bHQgYXNgIHN5bnRheC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqKi9cbmNvbnN0IG1vbWVudCA9IF9tb21lbnQ7XG5cbi8qKlxuICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIGBtaW51dGVgIHZpZXcuXG4gKi9cbmV4cG9ydCBjbGFzcyBEbE1pbnV0ZU1vZGVsUHJvdmlkZXIgaW1wbGVtZW50cyBEbE1vZGVsUHJvdmlkZXIge1xuXG4gIHByaXZhdGUgc3RlcCA9IDU7XG5cbiAgLyoqXG4gICAqIFJlY2VpdmVzIGBtaW51dGVTdGVwYCBjb25maWd1cmF0aW9uIGNoYW5nZXMgZGV0ZWN0ZWQgYnkgQW5ndWxhci5cbiAgICpcbiAgICogQ2hhbmdlcyB3aGVyZSB0aGUgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkIGFyZSBpZ25vcmVkLlxuICAgKlxuICAgKiBTZXR0aW5nIGBtaW51dGVTdGVwYCB0byBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgd2lsbCByZXN1bHQgaW4gYVxuICAgKiBtaW51dGVTdGVwIG9mIGA1YC5cbiAgICpcbiAgICogQHBhcmFtIGNoYW5nZXNcbiAgICogIHRoZSBpbnB1dCBjaGFuZ2VzIGRldGVjdGVkIGJ5IEFuZ3VsYXIuXG4gICAqL1xuXG4gIG9uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG5cbiAgICBjb25zdCBtaW51dGVTdGVwQ2hhbmdlID0gY2hhbmdlc1snbWludXRlU3RlcCddO1xuXG4gICAgaWYgKG1pbnV0ZVN0ZXBDaGFuZ2VcbiAgICAgICYmIChtaW51dGVTdGVwQ2hhbmdlLnByZXZpb3VzVmFsdWUgIT09IG1pbnV0ZVN0ZXBDaGFuZ2UuY3VycmVudFZhbHVlKVxuICAgICkge1xuICAgICAgdGhpcy5zdGVwID0gbWludXRlU3RlcENoYW5nZS5jdXJyZW50VmFsdWU7XG4gICAgICBpZiAodGhpcy5zdGVwID09PSBudWxsIHx8IHRoaXMuc3RlcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc3RlcCA9IDU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYG1pbnV0ZWAgbW9kZWwgZm9yIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIGBsb2NhbGAgdGltZSB3aXRoIHRoZVxuICAgKiBgYWN0aXZlYCBtaW51dGUgc2V0IHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGhvdXIuXG4gICAqXG4gICAqIFRoZSBgbWludXRlYCBtb2RlbCByZXByZXNlbnRzIGFuIGhvdXIgKDYwIG1pbnV0ZXMpIGFzIHRocmVlIHJvd3Mgd2l0aCBmb3VyIGNvbHVtbnNcbiAgICogYW5kIGVhY2ggY2VsbCByZXByZXNlbnRpbmcgNS1taW51dGUgaW5jcmVtZW50cy5cbiAgICpcbiAgICogVGhlIGhvdXIgYWx3YXlzIHN0YXJ0cyBhdCBtaWRuaWdodC5cbiAgICpcbiAgICogRWFjaCBjZWxsIHJlcHJlc2VudHMgYSA1LW1pbnV0ZSBpbmNyZW1lbnQgc3RhcnRpbmcgYXQgbWlkbmlnaHQuXG4gICAqXG4gICAqIFRoZSBgYWN0aXZlYCBtaW51dGUgd2lsbCBiZSB0aGUgNS1taW51dGUgaW5jcmVtZW50cyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZCBtaWxsaXNlY29uZHMuXG4gICAqXG4gICAqIEBwYXJhbSBtaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBtaW51dGUgbW9kZWwgd2lsbCBiZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgdGhlIG1vZGVsIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKi9cbiAgZ2V0TW9kZWwobWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IG1vbWVudChtaWxsaXNlY29uZHMpLnN0YXJ0T2YoJ2hvdXInKTtcbiAgICBjb25zdCBjdXJyZW50TWlsbGlzZWNvbmRzID0gbW9tZW50KCkudmFsdWVPZigpO1xuXG4gICAgY29uc3QgbWludXRlU3RlcHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKDYwIC8gdGhpcy5zdGVwKSkuZmlsbCgwKS5tYXAoKHZhbHVlLCBpbmRleCkgPT4gaW5kZXggKiB0aGlzLnN0ZXApO1xuICAgIGNvbnN0IG1pbnV0ZVZhbHVlcyA9IG1pbnV0ZVN0ZXBzLm1hcCgobWludXRlc1RvQWRkKSA9PiBtb21lbnQoc3RhcnREYXRlKS5hZGQobWludXRlc1RvQWRkLCAnbWludXRlcycpLnZhbHVlT2YoKSk7XG4gICAgY29uc3QgYWN0aXZlVmFsdWUgPSBtb21lbnQobWludXRlVmFsdWVzLmZpbHRlcigodmFsdWUpID0+IHZhbHVlIDw9IG1pbGxpc2Vjb25kcykucG9wKCkpLnZhbHVlT2YoKTtcblxuICAgIGNvbnN0IG5vd1ZhbHVlID0gY3VycmVudE1pbGxpc2Vjb25kcyA+PSBzdGFydERhdGUudmFsdWVPZigpICYmIGN1cnJlbnRNaWxsaXNlY29uZHMgPD0gbW9tZW50KHN0YXJ0RGF0ZSkuZW5kT2YoJ2hvdXInKS52YWx1ZU9mKClcbiAgICAgID8gbW9tZW50KG1pbnV0ZVZhbHVlcy5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSA8PSBjdXJyZW50TWlsbGlzZWNvbmRzKS5wb3AoKSkudmFsdWVPZigpXG4gICAgICA6IG51bGw7XG5cblxuICAgIGNvbnN0IHByZXZpb3VzSG91ciA9IG1vbWVudChzdGFydERhdGUpLnN1YnRyYWN0KDEsICdob3VyJyk7XG4gICAgY29uc3QgbmV4dEhvdXIgPSBtb21lbnQoc3RhcnREYXRlKS5hZGQoMSwgJ2hvdXInKTtcbiAgICBjb25zdCBzZWxlY3RlZFZhbHVlID0gc2VsZWN0ZWRNaWxsaXNlY29uZHMgPT09IG51bGwgfHwgc2VsZWN0ZWRNaWxsaXNlY29uZHMgPT09IHVuZGVmaW5lZFxuICAgICAgPyBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgICAgOiBtb21lbnQobWludXRlVmFsdWVzLmZpbHRlcigodmFsdWUpID0+IHZhbHVlIDw9IHNlbGVjdGVkTWlsbGlzZWNvbmRzKS5wb3AoKSkudmFsdWVPZigpO1xuXG4gICAgY29uc3Qgcm93cyA9IG5ldyBBcnJheShNYXRoLmNlaWwobWludXRlU3RlcHMubGVuZ3RoIC8gNCkpXG4gICAgICAuZmlsbCgwKVxuICAgICAgLm1hcCgodmFsdWUsIGluZGV4KSA9PiBpbmRleClcbiAgICAgIC5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiB7Y2VsbHM6IG1pbnV0ZVN0ZXBzLnNsaWNlKCh2YWx1ZSAqIDQpLCAodmFsdWUgKiA0KSArIDQpLm1hcChyb3dPZk1pbnV0ZXMpfTtcbiAgICAgIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0OiBEbERhdGVUaW1lUGlja2VyTW9kZWwgPSB7XG4gICAgICB2aWV3TmFtZTogJ21pbnV0ZScsXG4gICAgICB2aWV3TGFiZWw6IHN0YXJ0RGF0ZS5mb3JtYXQoJ2xsbCcpLFxuICAgICAgYWN0aXZlRGF0ZTogYWN0aXZlVmFsdWUsXG4gICAgICBsZWZ0QnV0dG9uOiB7XG4gICAgICAgIHZhbHVlOiBwcmV2aW91c0hvdXIudmFsdWVPZigpLFxuICAgICAgICBhcmlhTGFiZWw6IGBHbyB0byAke3ByZXZpb3VzSG91ci5mb3JtYXQoJ2xsbCcpfWAsXG4gICAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgfSxcbiAgICAgIHVwQnV0dG9uOiB7XG4gICAgICAgIHZhbHVlOiBzdGFydERhdGUudmFsdWVPZigpLFxuICAgICAgICBhcmlhTGFiZWw6IGBHbyB0byAke3N0YXJ0RGF0ZS5mb3JtYXQoJ2xsJyl9YCxcbiAgICAgICAgY2xhc3Nlczoge30sXG4gICAgICB9LFxuICAgICAgcmlnaHRCdXR0b246IHtcbiAgICAgICAgdmFsdWU6IG5leHRIb3VyLnZhbHVlT2YoKSxcbiAgICAgICAgYXJpYUxhYmVsOiBgR28gdG8gJHtuZXh0SG91ci5mb3JtYXQoJ2xsbCcpfWAsXG4gICAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgfSxcbiAgICAgIHJvd3NcbiAgICB9O1xuXG4gICAgcmVzdWx0LmxlZnRCdXR0b24uY2xhc3Nlc1tgJHtyZXN1bHQubGVmdEJ1dHRvbi52YWx1ZX1gXSA9IHRydWU7XG4gICAgcmVzdWx0LnJpZ2h0QnV0dG9uLmNsYXNzZXNbYCR7cmVzdWx0LnJpZ2h0QnV0dG9uLnZhbHVlfWBdID0gdHJ1ZTtcblxuICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBmdW5jdGlvbiByb3dPZk1pbnV0ZXMoc3RlcE1pbnV0ZXMpOiB7XG4gICAgICBkaXNwbGF5OiBzdHJpbmc7XG4gICAgICBhcmlhTGFiZWw6IHN0cmluZztcbiAgICAgIHZhbHVlOiBudW1iZXI7XG4gICAgICBjbGFzc2VzOiB7fTtcbiAgICB9IHtcbiAgICAgIGNvbnN0IG1pbnV0ZU1vbWVudCA9IG1vbWVudChzdGFydERhdGUpLmFkZChzdGVwTWludXRlcywgJ21pbnV0ZXMnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXk6IG1pbnV0ZU1vbWVudC5mb3JtYXQoJ0xUJyksXG4gICAgICAgIGFyaWFMYWJlbDogbWludXRlTW9tZW50LmZvcm1hdCgnTExMJyksXG4gICAgICAgIHZhbHVlOiBtaW51dGVNb21lbnQudmFsdWVPZigpLFxuICAgICAgICBjbGFzc2VzOiB7XG4gICAgICAgICAgJ2RsLWFiZHRwLWFjdGl2ZSc6IGFjdGl2ZVZhbHVlID09PSBtaW51dGVNb21lbnQudmFsdWVPZigpLFxuICAgICAgICAgICdkbC1hYmR0cC1zZWxlY3RlZCc6IHNlbGVjdGVkVmFsdWUgPT09IG1pbnV0ZU1vbWVudC52YWx1ZU9mKCksXG4gICAgICAgICAgJ2RsLWFiZHRwLW5vdyc6IG5vd1ZhbHVlID09PSBtaW51dGVNb21lbnQudmFsdWVPZigpLFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBhY3RpdmUgYG1pbnV0ZWAgb25lIHJvdyBgZG93bmAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKlxuICAgKiBNb3ZpbmcgYGRvd25gIGNhbiByZXN1bHQgaW4gdGhlIGBhY3RpdmVgIG1pbnV0ZSBiZWluZyBwYXJ0IG9mIGEgZGlmZmVyZW50IGhvdXIgdGhhblxuICAgKiB0aGUgc3BlY2lmaWVkIGBmcm9tTWlsbGlzZWNvbmRzYCwgaW4gdGhpcyBjYXNlIHRoZSBob3VyIHJlcHJlc2VudGVkIGJ5IHRoZSBtb2RlbFxuICAgKiB3aWxsIGNoYW5nZSB0byBzaG93IHRoZSBjb3JyZWN0IGhvdXIuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgbmV4dCBgbWludXRlYCBtb2RlbCBgZG93bmAgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIG1vZGVsIGNvbnRhaW5pbmcgYW4gYGFjdGl2ZWAgYG1pbnV0ZWAgb25lIHJvdyBgZG93bmAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKi9cbiAgZ29Eb3duKGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwobW9tZW50KGZyb21NaWxsaXNlY29uZHMpLmFkZCh0aGlzLnN0ZXAgKiA0LCAnbWludXRlcycpLnZhbHVlT2YoKSwgc2VsZWN0ZWRNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGFjdGl2ZSBgbWludXRlYCBvbmUgcm93IGBkb3duYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqXG4gICAqIE1vdmluZyBgZG93bmAgY2FuIHJlc3VsdCBpbiB0aGUgYGFjdGl2ZWAgbWludXRlIGJlaW5nIHBhcnQgb2YgYSBkaWZmZXJlbnQgaG91ciB0aGFuXG4gICAqIHRoZSBzcGVjaWZpZWQgYGZyb21NaWxsaXNlY29uZHNgLCBpbiB0aGlzIGNhc2UgdGhlIGhvdXIgcmVwcmVzZW50ZWQgYnkgdGhlIG1vZGVsXG4gICAqIHdpbGwgY2hhbmdlIHRvIHNob3cgdGhlIGNvcnJlY3QgaG91ci5cbiAgICpcbiAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBuZXh0IGBtaW51dGVgIG1vZGVsIGBkb3duYCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgbW9kZWwgY29udGFpbmluZyBhbiBgYWN0aXZlYCBgbWludXRlYCBvbmUgcm93IGBkb3duYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqL1xuICBnb1VwKGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwobW9tZW50KGZyb21NaWxsaXNlY29uZHMpLnN1YnRyYWN0KHRoaXMuc3RlcCAqIDQsICdtaW51dGVzJykudmFsdWVPZigpLCBzZWxlY3RlZE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgYGFjdGl2ZWAgZGF0ZSBvbmUgY2VsbCB0byBgbGVmdGAgaW4gdGhlIGN1cnJlbnQgYG1pbnV0ZWAgdmlldy5cbiAgICpcbiAgICogTW92aW5nIGBsZWZ0YCBjYW4gcmVzdWx0IGluIHRoZSBgYWN0aXZlYCBob3VyIGJlaW5nIHBhcnQgb2YgYSBkaWZmZXJlbnQgaG91ciB0aGFuXG4gICAqIHRoZSBzcGVjaWZpZWQgYGZyb21NaWxsaXNlY29uZHNgLCBpbiB0aGlzIGNhc2UgdGhlIGhvdXIgcmVwcmVzZW50ZWQgYnkgdGhlIG1vZGVsXG4gICAqIHdpbGwgY2hhbmdlIHRvIHNob3cgdGhlIGNvcnJlY3QgaG91ci5cbiAgICpcbiAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBgbWludXRlYCBtb2RlbCB0byB0aGUgYGxlZnRgIHdpbGwgYmUgY29uc3RydWN0ZWQuXG4gICAqIEBwYXJhbSBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBwaWNrZXIuXG4gICAqIEByZXR1cm5zXG4gICAqICBtb2RlbCBjb250YWluaW5nIGFuIGBhY3RpdmVgIGBtaW51dGVgIG9uZSBjZWxsIHRvIHRoZSBgbGVmdGAgb2YgdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICovXG4gIGdvTGVmdChmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLmdldE1vZGVsKG1vbWVudChmcm9tTWlsbGlzZWNvbmRzKS5zdWJ0cmFjdCh0aGlzLnN0ZXAsICdtaW51dGVzJykudmFsdWVPZigpLCBzZWxlY3RlZE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSBgYWN0aXZlYCBtaW51dGUgb25lIGNlbGwgdG8gYHJpZ2h0YCBpbiB0aGUgY3VycmVudCBgbWludXRlYCB2aWV3LlxuICAgKlxuICAgKiBNb3ZpbmcgYHJpZ2h0YCBjYW4gcmVzdWx0IGluIHRoZSBgYWN0aXZlYCBob3VyIGJlaW5nIHBhcnQgb2YgYSBkaWZmZXJlbnQgaG91ciB0aGFuXG4gICAqIHRoZSBzcGVjaWZpZWQgYGZyb21NaWxsaXNlY29uZHNgLCBpbiB0aGlzIGNhc2UgdGhlIGhvdXIgcmVwcmVzZW50ZWQgYnkgdGhlIG1vZGVsXG4gICAqIHdpbGwgY2hhbmdlIHRvIHNob3cgdGhlIGNvcnJlY3QgaG91ci5cbiAgICpcbiAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBgbWludXRlYCBtb2RlbCB0byB0aGUgYHJpZ2h0YCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgbW9kZWwgY29udGFpbmluZyBhbiBgYWN0aXZlYCBgbWludXRlYCBvbmUgY2VsbCB0byB0aGUgYHJpZ2h0YCBvZiB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKi9cbiAgZ29SaWdodChmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLmdldE1vZGVsKG1vbWVudChmcm9tTWlsbGlzZWNvbmRzKS5hZGQodGhpcy5zdGVwLCAnbWludXRlcycpLnZhbHVlT2YoKSwgc2VsZWN0ZWRNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGFjdGl2ZSBgbWludXRlYCBvbmUgaG91ciBgZG93bmAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKlxuICAgKiBUaGUgYGFjdGl2ZWAgbWludXRlIHdpbGwgYmUgYG9uZSAoMSkgaG91ciBhZnRlcmAgdGhlIHNwZWNpZmllZCBtaWxsaXNlY29uZHMuXG4gICAqIFRoaXMgbW92ZXMgdGhlIGBhY3RpdmVgIGRhdGUgb25lIGBwYWdlYCBgZG93bmAgZnJvbSB0aGUgY3VycmVudCBgbWludXRlYCB2aWV3LlxuICAgKlxuICAgKiBUaGUgbmV4dCBjZWxsIGBwYWdlLWRvd25gIHdpbGwgYmUgaW4gYSBkaWZmZXJlbnQgaG91ciB0aGFuIHRoZSBjdXJyZW50bHlcbiAgICogZGlzcGxheWVkIHZpZXcgYW5kIHRoZSBtb2RlbCB0aW1lIHJhbmdlIHdpbGwgaW5jbHVkZSB0aGUgbmV3IGFjdGl2ZSBjZWxsLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIG5leHQgYG1vbnRoYCBtb2RlbCBwYWdlIGBkb3duYCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgbW9kZWwgY29udGFpbmluZyBhbiBgYWN0aXZlYCBgbW9udGhgIG9uZSB5ZWFyIGBkb3duYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqL1xuICBwYWdlRG93bihmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLmdldE1vZGVsKG1vbWVudChmcm9tTWlsbGlzZWNvbmRzKS5hZGQoMSwgJ2hvdXInKS52YWx1ZU9mKCksIHNlbGVjdGVkTWlsbGlzZWNvbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBhY3RpdmUgYG1pbnV0ZWAgb25lIGhvdXIgYHVwYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqXG4gICAqIFRoZSBgYWN0aXZlYCBtaW51dGUgd2lsbCBiZSBgb25lICgxKSBob3VyIGJlZm9yZWAgdGhlIHNwZWNpZmllZCBtaWxsaXNlY29uZHMuXG4gICAqIFRoaXMgbW92ZXMgdGhlIGBhY3RpdmVgIGRhdGUgb25lIGBwYWdlYCBgZG93bmAgZnJvbSB0aGUgY3VycmVudCBgbWludXRlYCB2aWV3LlxuICAgKlxuICAgKiBUaGUgbmV4dCBjZWxsIGBwYWdlLXVwYCB3aWxsIGJlIGluIGEgZGlmZmVyZW50IGhvdXIgdGhhbiB0aGUgY3VycmVudGx5XG4gICAqIGRpc3BsYXllZCB2aWV3IGFuZCB0aGUgbW9kZWwgdGltZSByYW5nZSB3aWxsIGluY2x1ZGUgdGhlIG5ldyBhY3RpdmUgY2VsbC5cbiAgICpcbiAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBuZXh0IGBtb250aGAgbW9kZWwgcGFnZSBgZG93bmAgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIG1vZGVsIGNvbnRhaW5pbmcgYW4gYGFjdGl2ZWAgYG1vbnRoYCBvbmUgeWVhciBgZG93bmAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKi9cbiAgcGFnZVVwKGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwobW9tZW50KGZyb21NaWxsaXNlY29uZHMpLnN1YnRyYWN0KDEsICdob3VyJykudmFsdWVPZigpLCBzZWxlY3RlZE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgYGFjdGl2ZWAgYG1pbnV0ZWAgdG8gdGhlIGxhc3QgY2VsbCBvZiB0aGUgY3VycmVudCBob3VyLlxuICAgKlxuICAgKiBUaGUgdmlldyBvciB0aW1lIHJhbmdlIHdpbGwgbm90IGNoYW5nZSB1bmxlc3MgdGhlIGBmcm9tTWlsbGlzZWNvbmRzYCB2YWx1ZVxuICAgKiBpcyBpbiBhIGRpZmZlcmVudCBob3VyIHRoYW4gdGhlIGRpc3BsYXllZCBkZWNhZGUuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgbGFzdCBjZWxsIHdpbGwgYmUgY2FsY3VsYXRlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIGEgbW9kZWwgd2l0aCB0aGUgbGFzdCBjZWxsIGluIHRoZSB2aWV3IGFzIHRoZSBhY3RpdmUgYG1pbnV0ZWAuXG4gICAqL1xuICBnb0VuZChmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLmdldE1vZGVsKG1vbWVudChmcm9tTWlsbGlzZWNvbmRzKVxuICAgICAgLmVuZE9mKCdob3VyJylcbiAgICAgIC52YWx1ZU9mKCksIHNlbGVjdGVkTWlsbGlzZWNvbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBgYWN0aXZlYCBgbWludXRlYCB0byB0aGUgZmlyc3QgY2VsbCBvZiB0aGUgY3VycmVudCBob3VyLlxuICAgKlxuICAgKiBUaGUgdmlldyBvciB0aW1lIHJhbmdlIHdpbGwgbm90IGNoYW5nZSB1bmxlc3MgdGhlIGBmcm9tTWlsbGlzZWNvbmRzYCB2YWx1ZVxuICAgKiBpcyBpbiBhIGRpZmZlcmVudCBob3VyIHRoYW4gdGhlIGRpc3BsYXllZCBkZWNhZGUuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgZmlyc3QgY2VsbCB3aWxsIGJlIGNhbGN1bGF0ZWQuXG4gICAqIEBwYXJhbSBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBwaWNrZXIuXG4gICAqIEByZXR1cm5zXG4gICAqICBhIG1vZGVsIHdpdGggdGhlIGZpcnN0IGNlbGwgaW4gdGhlIHZpZXcgYXMgdGhlIGFjdGl2ZSBgbWludXRlYC5cbiAgICovXG4gIGdvSG9tZShmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLmdldE1vZGVsKG1vbWVudChmcm9tTWlsbGlzZWNvbmRzKS5zdGFydE9mKCdob3VyJykudmFsdWVPZigpLCBzZWxlY3RlZE1pbGxpc2Vjb25kcyk7XG4gIH1cbn1cbiJdfQ==