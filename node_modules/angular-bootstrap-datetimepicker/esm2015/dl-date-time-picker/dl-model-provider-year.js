/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright 2013-present Dale Lotts All Rights Reserved.
 * http://www.dalelotts.com
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
 */
import * as _moment from 'moment';
/**
 * Work around for moment namespace conflict when used with webpack and rollup.
 * See https://github.com/dherges/ng-packagr/issues/163
 *
 * Depending on whether rollup is used, moment needs to be imported differently.
 * Since Moment.js doesn't have a default export, we normally need to import using
 * the `* as`syntax.
 *
 * rollup creates a synthetic default module and we thus need to import it using
 * the `default as` syntax.
 *
 * \@internal
 *
 * @type {?}
 */
const moment = _moment;
/**
 * Default implementation for the `year` view.
 */
export class DlYearModelProvider {
    /**
     * Create a moment at midnight january 1 at the start of the current decade.
     * The start of the decade is always a year ending in zero.
     *
     * \@internal
     * @private
     * @param {?} fromMilliseconds
     *  the moment in time from which the start of the decade will be determined.
     * @return {?}
     *  moment at midnight january 1 at the start of the current decade.
     */
    static getStartOfDecade(fromMilliseconds) {
        // Truncate the last digit from the current year to get the start of the decade
        /** @type {?} */
        const startDecade = (Math.trunc(moment(fromMilliseconds).year() / 10) * 10);
        return moment({ year: startDecade }).startOf('year');
    }
    /**
     * Receives input changes detected by Angular.
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    onChanges(changes) {
    }
    /**
     * Returns the `year` model for the specified moment in `local` time with the
     * `active` year set to January 1 of the specified year.
     *
     * The `year` model represents a decade (10 years) as two rows with five columns.
     *
     * The decade always starts on a year ending with zero.
     *
     * Each cell represents midnight January 1 of the indicated year.
     *
     * The `active` year will be the January 1 of year of the specified milliseconds.
     *
     * @param {?} milliseconds
     *  the moment in time from which the year model will be created.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  the model representing the specified moment in time.
     */
    getModel(milliseconds, selectedMilliseconds) {
        /** @type {?} */
        const rowNumbers = [0, 1];
        /** @type {?} */
        const columnNumbers = [0, 1, 2, 3, 4];
        /** @type {?} */
        const startYear = moment(milliseconds).startOf('year');
        /** @type {?} */
        const startDate = DlYearModelProvider.getStartOfDecade(milliseconds);
        /** @type {?} */
        const futureYear = startDate.year() + 9;
        /** @type {?} */
        const pastYear = startDate.year();
        /** @type {?} */
        const activeValue = startYear.valueOf();
        /** @type {?} */
        const selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
            ? selectedMilliseconds
            : moment(selectedMilliseconds).startOf('year').valueOf();
        /** @type {?} */
        const result = {
            viewName: 'year',
            viewLabel: `${pastYear}-${futureYear}`,
            activeDate: activeValue,
            leftButton: {
                value: moment(startDate).subtract(10, 'years').valueOf(),
                ariaLabel: `Go to ${pastYear - 10}-${pastYear - 1}`,
                classes: {},
            },
            rightButton: {
                value: moment(startDate).add(10, 'years').valueOf(),
                ariaLabel: `Go to ${futureYear + 1}-${futureYear + 10}`,
                classes: {},
            },
            rows: rowNumbers.map(rowOfYears.bind(this))
        };
        result.leftButton.classes[`${result.leftButton.value}`] = true;
        result.rightButton.classes[`${result.rightButton.value}`] = true;
        return result;
        /**
         * @param {?} rowNumber
         * @return {?}
         */
        function rowOfYears(rowNumber) {
            /** @type {?} */
            const currentMoment = moment();
            /** @type {?} */
            const cells = columnNumbers.map((/**
             * @param {?} columnNumber
             * @return {?}
             */
            (columnNumber) => {
                /** @type {?} */
                const yearMoment = moment(startDate).add((rowNumber * columnNumbers.length) + columnNumber, 'years');
                return {
                    display: yearMoment.format('YYYY'),
                    value: yearMoment.valueOf(),
                    classes: {
                        'dl-abdtp-active': activeValue === yearMoment.valueOf(),
                        'dl-abdtp-selected': selectedValue === yearMoment.valueOf(),
                        'dl-abdtp-now': yearMoment.isSame(currentMoment, 'year'),
                    }
                };
            }));
            return { cells };
        }
    }
    /**
     * Move the active `year` one row `down` from the specified moment in time.
     *
     * The `active` year will be the January 1 `five (5) years after` the specified milliseconds.
     * This moves the `active` date one row `down` in the current `year` view.
     *
     * Moving `down` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `year` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one row `down` from the specified moment in time.
     */
    goDown(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(5, 'year').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the active `year` one row `up` from the specified moment in time.
     *
     * The `active` year will be the January 1 `five (5) years before` the specified milliseconds.
     * This moves the `active` date one row `up` in the current `year` view.
     *
     * Moving `up` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the previous `year` model `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one row `up` from the specified moment in time.
     */
    goUp(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(5, 'year').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the `active` `year` one (1) year to the `left` of the specified moment in time.
     *
     * The `active` year will be the January 1 `one (1) year before` the specified milliseconds.
     * This moves the `active` date one year `left` in the current `year` view.
     *
     * Moving `left` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `year` model to the `left` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one year to the `left` of the specified moment in time.
     */
    goLeft(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(1, 'year').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the `active` `year` one (1) year to the `right` of the specified moment in time.
     *
     * The `active` year will be the January 1 `one (1) year after` the specified milliseconds.
     * This moves the `active` date one year `right` in the current `year` view.
     *
     * Moving `right` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `year` model to the `right` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one year to the `right` of the specified moment in time.
     */
    goRight(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(1, 'year').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the active `year` one decade `down` from the specified moment in time.
     *
     * The `active` year will be the January 1 `ten (10) years after` the specified milliseconds.
     * This moves the `active` date one `page` `down` from the current `year` view.
     *
     * Paging `down` will result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`. As a result, the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `year` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one decade `down` from the specified moment in time.
     */
    pageDown(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(10, 'year').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the active `year` one decade `up` from the specified moment in time.
     *
     * The `active` year will be the January 1 `ten (10) years before` the specified milliseconds.
     * This moves the `active` date one `page-up` from the current `year` view.
     *
     * Paging `up` will result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`. As a result, the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `year` model page `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one decade `up` from the specified moment in time.
     */
    pageUp(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(10, 'year').valueOf(), selectedMilliseconds);
    }
    /**
     * Move the `active` `year` to the `last` year in the decade.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different decade than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `last` active `year` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `last` cell in the view as the active `year`.
     */
    goEnd(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(DlYearModelProvider.getStartOfDecade(fromMilliseconds)
            .add(9, 'years')
            .endOf('year')
            .valueOf(), selectedMilliseconds);
    }
    /**
     * Move the `active` `year` to the `first` year in the decade.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different decade than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `first` active `year` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `first` cell in the view as the active `year`.
     */
    goHome(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(DlYearModelProvider.getStartOfDecade(fromMilliseconds)
            .startOf('year')
            .valueOf(), selectedMilliseconds);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGwtbW9kZWwtcHJvdmlkZXIteWVhci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLyIsInNvdXJjZXMiOlsiZGwtZGF0ZS10aW1lLXBpY2tlci9kbC1tb2RlbC1wcm92aWRlci15ZWFyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQVVBLE9BQU8sS0FBSyxPQUFPLE1BQU0sUUFBUSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O01Ba0I1QixNQUFNLEdBQUcsT0FBTzs7OztBQUt0QixNQUFNLE9BQU8sbUJBQW1COzs7Ozs7Ozs7Ozs7SUFZdEIsTUFBTSxDQUFDLGdCQUFnQixDQUFDLGdCQUF3Qjs7O2NBRWhELFdBQVcsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzNFLE9BQU8sTUFBTSxDQUFDLEVBQUMsSUFBSSxFQUFFLFdBQVcsRUFBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3JELENBQUM7Ozs7Ozs7O0lBUUQsU0FBUyxDQUFDLE9BQXNCO0lBQ2hDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBcUJELFFBQVEsQ0FBQyxZQUFvQixFQUFFLG9CQUE0Qjs7Y0FDbkQsVUFBVSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7Y0FDbkIsYUFBYSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7Y0FFL0IsU0FBUyxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDOztjQUNoRCxTQUFTLEdBQUcsbUJBQW1CLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxDQUFDOztjQUU5RCxVQUFVLEdBQUcsU0FBUyxDQUFDLElBQUksRUFBRSxH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Q3RHLENBQUM7Ozs7Ozs7Ozs7Ozs7O0lBZUQsS0FBSyxDQUFDLGdCQUF3QixFQUFFLG9CQUE0QjtRQUMxRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQ2xCLG1CQUFtQixDQUFDLGdCQUFnQixDQUFDLGdCQUFnQixDQUFDO2FBQ25ELEdBQUcsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDO2FBQ2YsS0FBSyxDQUFDLE1BQU0sQ0FBQzthQUNiLE9BQU8sRUFBRSxFQUNaLG9CQUFvQixDQUNyQixDQUFDO0lBQ0osQ0FBQzs7Ozs7Ozs7Ozs7Ozs7SUFlRCxNQUFNLENBQUMsZ0JBQXdCLEVBQUUsb0JBQTRCO1FBQzNELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FDbEIsbUJBQW1CLENBQUMsZ0JBQWdCLENBQUMsZ0JBQWdCLENBQUM7YUFDbkQsT0FBTyxDQUFDLE1BQU0sQ0FBQzthQUNmLE9BQU8sRUFBRSxFQUNaLG9CQUFvQixDQUNyQixDQUFDO0lBQ0osQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCBEYWxlIExvdHRzIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmRhbGVsb3R0cy5jb21cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2dpdGh1Yi5jb20vZGFsZWxvdHRzL2FuZ3VsYXItYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG5pbXBvcnQge1NpbXBsZUNoYW5nZXN9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgX21vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHtNb21lbnR9IGZyb20gJ21vbWVudCc7XG5pbXBvcnQge0RsRGF0ZVRpbWVQaWNrZXJNb2RlbH0gZnJvbSAnLi9kbC1kYXRlLXRpbWUtcGlja2VyLW1vZGVsJztcbmltcG9ydCB7RGxNb2RlbFByb3ZpZGVyfSBmcm9tICcuL2RsLW1vZGVsLXByb3ZpZGVyJztcblxuLyoqXG4gKiBXb3JrIGFyb3VuZCBmb3IgbW9tZW50IG5hbWVzcGFjZSBjb25mbGljdCB3aGVuIHVzZWQgd2l0aCB3ZWJwYWNrIGFuZCByb2xsdXAuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2RoZXJnZXMvbmctcGFja2Fnci9pc3N1ZXMvMTYzXG4gKlxuICogRGVwZW5kaW5nIG9uIHdoZXRoZXIgcm9sbHVwIGlzIHVzZWQsIG1vbWVudCBuZWVkcyB0byBiZSBpbXBvcnRlZCBkaWZmZXJlbnRseS5cbiAqIFNpbmNlIE1vbWVudC5qcyBkb2Vzbid0IGhhdmUgYSBkZWZhdWx0IGV4cG9ydCwgd2Ugbm9ybWFsbHkgbmVlZCB0byBpbXBvcnQgdXNpbmdcbiAqIHRoZSBgKiBhc2BzeW50YXguXG4gKlxuICogcm9sbHVwIGNyZWF0ZXMgYSBzeW50aGV0aWMgZGVmYXVsdCBtb2R1bGUgYW5kIHdlIHRodXMgbmVlZCB0byBpbXBvcnQgaXQgdXNpbmdcbiAqIHRoZSBgZGVmYXVsdCBhc2Agc3ludGF4LlxuICpcbiAqIEBpbnRlcm5hbFxuICoqL1xuY29uc3QgbW9tZW50ID0gX21vbWVudDtcblxuLyoqXG4gKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciB0aGUgYHllYXJgIHZpZXcuXG4gKi9cbmV4cG9ydCBjbGFzcyBEbFllYXJNb2RlbFByb3ZpZGVyIGltcGxlbWVudHMgRGxNb2RlbFByb3ZpZGVyIHtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbW9tZW50IGF0IG1pZG5pZ2h0IGphbnVhcnkgMSBhdCB0aGUgc3RhcnQgb2YgdGhlIGN1cnJlbnQgZGVjYWRlLlxuICAgKiBUaGUgc3RhcnQgb2YgdGhlIGRlY2FkZSBpcyBhbHdheXMgYSB5ZWFyIGVuZGluZyBpbiB6ZXJvLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIHN0YXJ0IG9mIHRoZSBkZWNhZGUgd2lsbCBiZSBkZXRlcm1pbmVkLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgbW9tZW50IGF0IG1pZG5pZ2h0IGphbnVhcnkgMSBhdCB0aGUgc3RhcnQgb2YgdGhlIGN1cnJlbnQgZGVjYWRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGdldFN0YXJ0T2ZEZWNhZGUoZnJvbU1pbGxpc2Vjb25kczogbnVtYmVyKTogTW9tZW50IHtcbiAgICAvLyBUcnVuY2F0ZSB0aGUgbGFzdCBkaWdpdCBmcm9tIHRoZSBjdXJyZW50IHllYXIgdG8gZ2V0IHRoZSBzdGFydCBvZiB0aGUgZGVjYWRlXG4gICAgY29uc3Qgc3RhcnREZWNhZGUgPSAoTWF0aC50cnVuYyhtb21lbnQoZnJvbU1pbGxpc2Vjb25kcykueWVhcigpIC8gMTApICogMTApO1xuICAgIHJldHVybiBtb21lbnQoe3llYXI6IHN0YXJ0RGVjYWRlfSkuc3RhcnRPZigneWVhcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY2VpdmVzIGlucHV0IGNoYW5nZXMgZGV0ZWN0ZWQgYnkgQW5ndWxhci5cbiAgICpcbiAgICogQHBhcmFtIGNoYW5nZXNcbiAgICogIHRoZSBpbnB1dCBjaGFuZ2VzIGRldGVjdGVkIGJ5IEFuZ3VsYXIuXG4gICAqL1xuICBvbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGB5ZWFyYCBtb2RlbCBmb3IgdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gYGxvY2FsYCB0aW1lIHdpdGggdGhlXG4gICAqIGBhY3RpdmVgIHllYXIgc2V0IHRvIEphbnVhcnkgMSBvZiB0aGUgc3BlY2lmaWVkIHllYXIuXG4gICAqXG4gICAqIFRoZSBgeWVhcmAgbW9kZWwgcmVwcmVzZW50cyBhIGRlY2FkZSAoMTAgeWVhcnMpIGFzIHR3byByb3dzIHdpdGggZml2ZSBjb2x1bW5zLlxuICAgKlxuICAgKiBUaGUgZGVjYWRlIGFsd2F5cyBzdGFydHMgb24gYSB5ZWFyIGVuZGluZyB3aXRoIHplcm8uXG4gICAqXG4gICAqIEVhY2ggY2VsbCByZXByZXNlbnRzIG1pZG5pZ2h0IEphbnVhcnkgMSBvZiB0aGUgaW5kaWNhdGVkIHllYXIuXG4gICAqXG4gICAqIFRoZSBgYWN0aXZlYCB5ZWFyIHdpbGwgYmUgdGhlIEphbnVhcnkgMSBvZiB5ZWFyIG9mIHRoZSBzcGVjaWZpZWQgbWlsbGlzZWNvbmRzLlxuICAgKlxuICAgKiBAcGFyYW0gbWlsbGlzZWNvbmRzXG4gICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgeWVhciBtb2RlbCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBwaWNrZXIuXG4gICAqIEByZXR1cm5zXG4gICAqICB0aGUgbW9kZWwgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqL1xuICBnZXRNb2RlbChtaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgY29uc3Qgcm93TnVtYmVycyA9IFswLCAxXTtcbiAgICBjb25zdCBjb2x1bW5OdW1iZXJzID0gWzAsIDEsIDIsIDMsIDRdO1xuXG4gICAgY29uc3Qgc3RhcnRZZWFyID0gbW9tZW50KG1pbGxpc2Vjb25kcykuc3RhcnRPZigneWVhcicpO1xuICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IERsWWVhck1vZGVsUHJvdmlkZXIuZ2V0U3RhcnRPZkRlY2FkZShtaWxsaXNlY29uZHMpO1xuXG4gICAgY29uc3QgZnV0dXJlWWVhciA9IHN0YXJ0RGF0ZS55ZWFyKCkgKyA5O1xuICAgIGNvbnN0IHBhc3RZZWFyID0gc3RhcnREYXRlLnllYXIoKTtcbiAgICBjb25zdCBhY3RpdmVWYWx1ZSA9IHN0YXJ0WWVhci52YWx1ZU9mKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWRWYWx1ZSA9IHNlbGVjdGVkTWlsbGlzZWNvbmRzID09PSBudWxsIHx8IHNlbGVjdGVkTWlsbGlzZWNvbmRzID09PSB1bmRlZmluZWRcbiAgICAgID8gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICAgIDogbW9tZW50KHNlbGVjdGVkTWlsbGlzZWNvbmRzKS5zdGFydE9mKCd5ZWFyJykudmFsdWVPZigpO1xuXG4gICAgY29uc3QgcmVzdWx0OiBEbERhdGVUaW1lUGlja2VyTW9kZWwgPSB7XG4gICAgICB2aWV3TmFtZTogJ3llYXInLFxuICAgICAgdmlld0xhYmVsOiBgJHtwYXN0WWVhcn0tJHtmdXR1cmVZZWFyfWAsXG4gICAgICBhY3RpdmVEYXRlOiBhY3RpdmVWYWx1ZSxcbiAgICAgIGxlZnRCdXR0b246IHtcbiAgICAgICAgdmFsdWU6IG1vbWVudChzdGFydERhdGUpLnN1YnRyYWN0KDEwLCAneWVhcnMnKS52YWx1ZU9mKCksXG4gICAgICAgIGFyaWFMYWJlbDogYEdvIHRvICR7cGFzdFllYXIgLSAxMH0tJHtwYXN0WWVhciAtIDF9YCxcbiAgICAgICAgY2xhc3Nlczoge30sXG4gICAgICB9LFxuICAgICAgcmlnaHRCdXR0b246IHtcbiAgICAgICAgdmFsdWU6IG1vbWVudChzdGFydERhdGUpLmFkZCgxMCwgJ3llYXJzJykudmFsdWVPZigpLFxuICAgICAgICBhcmlhTGFiZWw6IGBHbyB0byAke2Z1dHVyZVllYXIgKyAxfS0ke2Z1dHVyZVllYXIgKyAxMH1gLFxuICAgICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIH0sXG4gICAgICByb3dzOiByb3dOdW1iZXJzLm1hcChyb3dPZlllYXJzLmJpbmQodGhpcykpXG4gICAgfTtcblxuICAgIHJlc3VsdC5sZWZ0QnV0dG9uLmNsYXNzZXNbYCR7cmVzdWx0LmxlZnRCdXR0b24udmFsdWV9YF0gPSB0cnVlO1xuICAgIHJlc3VsdC5yaWdodEJ1dHRvbi5jbGFzc2VzW2Ake3Jlc3VsdC5yaWdodEJ1dHRvbi52YWx1ZX1gXSA9IHRydWU7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgZnVuY3Rpb24gcm93T2ZZZWFycyhyb3dOdW1iZXIpIHtcblxuICAgICAgY29uc3QgY3VycmVudE1vbWVudCA9IG1vbWVudCgpO1xuICAgICAgY29uc3QgY2VsbHMgPSBjb2x1bW5OdW1iZXJzLm1hcCgoY29sdW1uTnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHllYXJNb21lbnQgPSBtb21lbnQoc3RhcnREYXRlKS5hZGQoKHJvd051bWJlciAqIGNvbHVtbk51bWJlcnMubGVuZ3RoKSArIGNvbHVtbk51bWJlciwgJ3llYXJzJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlzcGxheTogeWVhck1vbWVudC5mb3JtYXQoJ1lZWVknKSxcbiAgICAgICAgICB2YWx1ZTogeWVhck1vbWVudC52YWx1ZU9mKCksXG4gICAgICAgICAgY2xhc3Nlczoge1xuICAgICAgICAgICAgJ2RsLWFiZHRwLWFjdGl2ZSc6IGFjdGl2ZVZhbHVlID09PSB5ZWFyTW9tZW50LnZhbHVlT2YoKSxcbiAgICAgICAgICAgICdkbC1hYmR0cC1zZWxlY3RlZCc6IHNlbGVjdGVkVmFsdWUgPT09IHllYXJNb21lbnQudmFsdWVPZigpLFxuICAgICAgICAgICAgJ2RsLWFiZHRwLW5vdyc6IHllYXJNb21lbnQuaXNTYW1lKGN1cnJlbnRNb21lbnQsICd5ZWFyJyksXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge2NlbGxzfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgYWN0aXZlIGB5ZWFyYCBvbmUgcm93IGBkb3duYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqXG4gICAqIFRoZSBgYWN0aXZlYCB5ZWFyIHdpbGwgYmUgdGhlIEphbnVhcnkgMSBgZml2ZSAoNSkgeWVhcnMgYWZ0ZXJgIHRoZSBzcGVjaWZpZWQgbWlsbGlzZWNvbmRzLlxuICAgKiBUaGlzIG1vdmVzIHRoZSBgYWN0aXZlYCBkYXRlIG9uZSByb3cgYGRvd25gIGluIHRoZSBjdXJyZW50IGB5ZWFyYCB2aWV3LlxuICAgKlxuICAgKiBNb3ZpbmcgYGRvd25gIGNhbiByZXN1bHQgaW4gdGhlIGBhY3RpdmVgIHllYXIgYmVpbmcgcGFydCBvZiBhIGRpZmZlcmVudCBkZWNhZGUgdGhhblxuICAgKiB0aGUgc3BlY2lmaWVkIGBmcm9tTWlsbGlzZWNvbmRzYCwgaW4gdGhpcyBjYXNlIHRoZSBkZWNhZGUgcmVwcmVzZW50ZWQgYnkgdGhlIG1vZGVsXG4gICAqIHdpbGwgY2hhbmdlIHRvIHNob3cgdGhlIGNvcnJlY3QgZGVjYWRlLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIG5leHQgYHllYXJgIG1vZGVsIGBkb3duYCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgbW9kZWwgY29udGFpbmluZyBhbiBgYWN0aXZlYCBgeWVhcmAgb25lIHJvdyBgZG93bmAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKi9cbiAgZ29Eb3duKGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwobW9tZW50KGZyb21NaWxsaXNlY29uZHMpLmFkZCg1LCAneWVhcicpLnZhbHVlT2YoKSwgc2VsZWN0ZWRNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGFjdGl2ZSBgeWVhcmAgb25lIHJvdyBgdXBgIGZyb20gdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICpcbiAgICogVGhlIGBhY3RpdmVgIHllYXIgd2lsbCBiZSB0aGUgSmFudWFyeSAxIGBmaXZlICg1KSB5ZWFycyBiZWZvcmVgIHRoZSBzcGVjaWZpZWQgbWlsbGlzZWNvbmRzLlxuICAgKiBUaGlzIG1vdmVzIHRoZSBgYWN0aXZlYCBkYXRlIG9uZSByb3cgYHVwYCBpbiB0aGUgY3VycmVudCBgeWVhcmAgdmlldy5cbiAgICpcbiAgICogTW92aW5nIGB1cGAgY2FuIHJlc3VsdCBpbiB0aGUgYGFjdGl2ZWAgeWVhciBiZWluZyBwYXJ0IG9mIGEgZGlmZmVyZW50IGRlY2FkZSB0aGFuXG4gICAqIHRoZSBzcGVjaWZpZWQgYGZyb21NaWxsaXNlY29uZHNgLCBpbiB0aGlzIGNhc2UgdGhlIGRlY2FkZSByZXByZXNlbnRlZCBieSB0aGUgbW9kZWxcbiAgICogd2lsbCBjaGFuZ2UgdG8gc2hvdyB0aGUgY29ycmVjdCBkZWNhZGUuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgcHJldmlvdXMgYHllYXJgIG1vZGVsIGB1cGAgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIG1vZGVsIGNvbnRhaW5pbmcgYW4gYGFjdGl2ZWAgYHllYXJgIG9uZSByb3cgYHVwYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqL1xuICBnb1VwKGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwobW9tZW50KGZyb21NaWxsaXNlY29uZHMpLnN1YnRyYWN0KDUsICd5ZWFyJykudmFsdWVPZigpLCBzZWxlY3RlZE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgYGFjdGl2ZWAgYHllYXJgIG9uZSAoMSkgeWVhciB0byB0aGUgYGxlZnRgIG9mIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqXG4gICAqIFRoZSBgYWN0aXZlYCB5ZWFyIHdpbGwgYmUgdGhlIEphbnVhcnkgMSBgb25lICgxKSB5ZWFyIGJlZm9yZWAgdGhlIHNwZWNpZmllZCBtaWxsaXNlY29uZHMuXG4gICAqIFRoaXMgbW92ZXMgdGhlIGBhY3RpdmVgIGRhdGUgb25lIHllYXIgYGxlZnRgIGluIHRoZSBjdXJyZW50IGB5ZWFyYCB2aWV3LlxuICAgKlxuICAgKiBNb3ZpbmcgYGxlZnRgIGNhbiByZXN1bHQgaW4gdGhlIGBhY3RpdmVgIHllYXIgYmVpbmcgcGFydCBvZiBhIGRpZmZlcmVudCBkZWNhZGUgdGhhblxuICAgKiB0aGUgc3BlY2lmaWVkIGBmcm9tTWlsbGlzZWNvbmRzYCwgaW4gdGhpcyBjYXNlIHRoZSBkZWNhZGUgcmVwcmVzZW50ZWQgYnkgdGhlIG1vZGVsXG4gICAqIHdpbGwgY2hhbmdlIHRvIHNob3cgdGhlIGNvcnJlY3QgZGVjYWRlLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIGB5ZWFyYCBtb2RlbCB0byB0aGUgYGxlZnRgIHdpbGwgYmUgY29uc3RydWN0ZWQuXG4gICAqIEBwYXJhbSBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBwaWNrZXIuXG4gICAqIEByZXR1cm5zXG4gICAqICBtb2RlbCBjb250YWluaW5nIGFuIGBhY3RpdmVgIGB5ZWFyYCBvbmUgeWVhciB0byB0aGUgYGxlZnRgIG9mIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqL1xuICBnb0xlZnQoZnJvbU1pbGxpc2Vjb25kczogbnVtYmVyLCBzZWxlY3RlZE1pbGxpc2Vjb25kczogbnVtYmVyKTogRGxEYXRlVGltZVBpY2tlck1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNb2RlbChtb21lbnQoZnJvbU1pbGxpc2Vjb25kcykuc3VidHJhY3QoMSwgJ3llYXInKS52YWx1ZU9mKCksIHNlbGVjdGVkTWlsbGlzZWNvbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBgYWN0aXZlYCBgeWVhcmAgb25lICgxKSB5ZWFyIHRvIHRoZSBgcmlnaHRgIG9mIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqXG4gICAqIFRoZSBgYWN0aXZlYCB5ZWFyIHdpbGwgYmUgdGhlIEphbnVhcnkgMSBgb25lICgxKSB5ZWFyIGFmdGVyYCB0aGUgc3BlY2lmaWVkIG1pbGxpc2Vjb25kcy5cbiAgICogVGhpcyBtb3ZlcyB0aGUgYGFjdGl2ZWAgZGF0ZSBvbmUgeWVhciBgcmlnaHRgIGluIHRoZSBjdXJyZW50IGB5ZWFyYCB2aWV3LlxuICAgKlxuICAgKiBNb3ZpbmcgYHJpZ2h0YCBjYW4gcmVzdWx0IGluIHRoZSBgYWN0aXZlYCB5ZWFyIGJlaW5nIHBhcnQgb2YgYSBkaWZmZXJlbnQgZGVjYWRlIHRoYW5cbiAgICogdGhlIHNwZWNpZmllZCBgZnJvbU1pbGxpc2Vjb25kc2AsIGluIHRoaXMgY2FzZSB0aGUgZGVjYWRlIHJlcHJlc2VudGVkIGJ5IHRoZSBtb2RlbFxuICAgKiB3aWxsIGNoYW5nZSB0byBzaG93IHRoZSBjb3JyZWN0IGRlY2FkZS5cbiAgICpcbiAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBgeWVhcmAgbW9kZWwgdG8gdGhlIGByaWdodGAgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIG1vZGVsIGNvbnRhaW5pbmcgYW4gYGFjdGl2ZWAgYHllYXJgIG9uZSB5ZWFyIHRvIHRoZSBgcmlnaHRgIG9mIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqL1xuICBnb1JpZ2h0KGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwobW9tZW50KGZyb21NaWxsaXNlY29uZHMpLmFkZCgxLCAneWVhcicpLnZhbHVlT2YoKSwgc2VsZWN0ZWRNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGFjdGl2ZSBgeWVhcmAgb25lIGRlY2FkZSBgZG93bmAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKlxuICAgKiBUaGUgYGFjdGl2ZWAgeWVhciB3aWxsIGJlIHRoZSBKYW51YXJ5IDEgYHRlbiAoMTApIHllYXJzIGFmdGVyYCB0aGUgc3BlY2lmaWVkIG1pbGxpc2Vjb25kcy5cbiAgICogVGhpcyBtb3ZlcyB0aGUgYGFjdGl2ZWAgZGF0ZSBvbmUgYHBhZ2VgIGBkb3duYCBmcm9tIHRoZSBjdXJyZW50IGB5ZWFyYCB2aWV3LlxuICAgKlxuICAgKiBQYWdpbmcgYGRvd25gIHdpbGwgcmVzdWx0IGluIHRoZSBgYWN0aXZlYCB5ZWFyIGJlaW5nIHBhcnQgb2YgYSBkaWZmZXJlbnQgZGVjYWRlIHRoYW5cbiAgICogdGhlIHNwZWNpZmllZCBgZnJvbU1pbGxpc2Vjb25kc2AuIEFzIGEgcmVzdWx0LCB0aGUgZGVjYWRlIHJlcHJlc2VudGVkIGJ5IHRoZSBtb2RlbFxuICAgKiB3aWxsIGNoYW5nZSB0byBzaG93IHRoZSBjb3JyZWN0IGRlY2FkZS5cbiAgICpcbiAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBuZXh0IGB5ZWFyYCBtb2RlbCBwYWdlIGBkb3duYCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgbW9kZWwgY29udGFpbmluZyBhbiBgYWN0aXZlYCBgeWVhcmAgb25lIGRlY2FkZSBgZG93bmAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKi9cbiAgcGFnZURvd24oZnJvbU1pbGxpc2Vjb25kczogbnVtYmVyLCBzZWxlY3RlZE1pbGxpc2Vjb25kczogbnVtYmVyKTogRGxEYXRlVGltZVBpY2tlck1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNb2RlbChtb21lbnQoZnJvbU1pbGxpc2Vjb25kcykuYWRkKDEwLCAneWVhcicpLnZhbHVlT2YoKSwgc2VsZWN0ZWRNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGFjdGl2ZSBgeWVhcmAgb25lIGRlY2FkZSBgdXBgIGZyb20gdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICpcbiAgICogVGhlIGBhY3RpdmVgIHllYXIgd2lsbCBiZSB0aGUgSmFudWFyeSAxIGB0ZW4gKDEwKSB5ZWFycyBiZWZvcmVgIHRoZSBzcGVjaWZpZWQgbWlsbGlzZWNvbmRzLlxuICAgKiBUaGlzIG1vdmVzIHRoZSBgYWN0aXZlYCBkYXRlIG9uZSBgcGFnZS11cGAgZnJvbSB0aGUgY3VycmVudCBgeWVhcmAgdmlldy5cbiAgICpcbiAgICogUGFnaW5nIGB1cGAgd2lsbCByZXN1bHQgaW4gdGhlIGBhY3RpdmVgIHllYXIgYmVpbmcgcGFydCBvZiBhIGRpZmZlcmVudCBkZWNhZGUgdGhhblxuICAgKiB0aGUgc3BlY2lmaWVkIGBmcm9tTWlsbGlzZWNvbmRzYC4gQXMgYSByZXN1bHQsIHRoZSBkZWNhZGUgcmVwcmVzZW50ZWQgYnkgdGhlIG1vZGVsXG4gICAqIHdpbGwgY2hhbmdlIHRvIHNob3cgdGhlIGNvcnJlY3QgZGVjYWRlLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIG5leHQgYHllYXJgIG1vZGVsIHBhZ2UgYHVwYCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgbW9kZWwgY29udGFpbmluZyBhbiBgYWN0aXZlYCBgeWVhcmAgb25lIGRlY2FkZSBgdXBgIGZyb20gdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICovXG4gIHBhZ2VVcChmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLmdldE1vZGVsKG1vbWVudChmcm9tTWlsbGlzZWNvbmRzKS5zdWJ0cmFjdCgxMCwgJ3llYXInKS52YWx1ZU9mKCksIHNlbGVjdGVkTWlsbGlzZWNvbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBgYWN0aXZlYCBgeWVhcmAgdG8gdGhlIGBsYXN0YCB5ZWFyIGluIHRoZSBkZWNhZGUuXG4gICAqXG4gICAqIFRoZSB2aWV3IG9yIHRpbWUgcmFuZ2Ugd2lsbCBub3QgY2hhbmdlIHVubGVzcyB0aGUgYGZyb21NaWxsaXNlY29uZHNgIHZhbHVlXG4gICAqIGlzIGluIGEgZGlmZmVyZW50IGRlY2FkZSB0aGFuIHRoZSBkaXNwbGF5ZWQgZGVjYWRlLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIGBsYXN0YCBhY3RpdmUgYHllYXJgIHdpbGwgYmUgY2FsY3VsYXRlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIGEgbW9kZWwgd2l0aCB0aGUgYGxhc3RgIGNlbGwgaW4gdGhlIHZpZXcgYXMgdGhlIGFjdGl2ZSBgeWVhcmAuXG4gICAqL1xuICBnb0VuZChmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLmdldE1vZGVsKFxuICAgICAgRGxZZWFyTW9kZWxQcm92aWRlci5nZXRTdGFydE9mRGVjYWRlKGZyb21NaWxsaXNlY29uZHMpXG4gICAgICAgIC5hZGQoOSwgJ3llYXJzJylcbiAgICAgICAgLmVuZE9mKCd5ZWFyJylcbiAgICAgICAgLnZhbHVlT2YoKSxcbiAgICAgIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBgYWN0aXZlYCBgeWVhcmAgdG8gdGhlIGBmaXJzdGAgeWVhciBpbiB0aGUgZGVjYWRlLlxuICAgKlxuICAgKiBUaGUgdmlldyBvciB0aW1lIHJhbmdlIHdpbGwgbm90IGNoYW5nZSB1bmxlc3MgdGhlIGBmcm9tTWlsbGlzZWNvbmRzYCB2YWx1ZVxuICAgKiBpcyBpbiBhIGRpZmZlcmVudCBkZWNhZGUgdGhhbiB0aGUgZGlzcGxheWVkIGRlY2FkZS5cbiAgICpcbiAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBgZmlyc3RgIGFjdGl2ZSBgeWVhcmAgd2lsbCBiZSBjYWxjdWxhdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgYSBtb2RlbCB3aXRoIHRoZSBgZmlyc3RgIGNlbGwgaW4gdGhlIHZpZXcgYXMgdGhlIGFjdGl2ZSBgeWVhcmAuXG4gICAqL1xuICBnb0hvbWUoZnJvbU1pbGxpc2Vjb25kczogbnVtYmVyLCBzZWxlY3RlZE1pbGxpc2Vjb25kczogbnVtYmVyKTogRGxEYXRlVGltZVBpY2tlck1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNb2RlbChcbiAgICAgIERsWWVhck1vZGVsUHJvdmlkZXIuZ2V0U3RhcnRPZkRlY2FkZShmcm9tTWlsbGlzZWNvbmRzKVxuICAgICAgICAuc3RhcnRPZigneWVhcicpXG4gICAgICAgIC52YWx1ZU9mKCksXG4gICAgICBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgICk7XG4gIH1cbn1cbiJdfQ==