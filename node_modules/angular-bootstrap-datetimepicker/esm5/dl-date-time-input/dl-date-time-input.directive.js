/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, EventEmitter, forwardRef, HostListener, Inject, Input, Output, Renderer2 } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators, } from '@angular/forms';
import * as _moment from 'moment';
import { DL_DATE_TIME_DISPLAY_FORMAT, DL_DATE_TIME_INPUT_FORMATS, DlDateAdapter } from '../core';
import { DlDateTimeInputChange } from './dl-date-time-input-change';
/**
 * \@internal
 * @type {?}
 */
var moment = _moment;
/**
 * \@internal
 * @type {?}
 */
var alwaysTrueInputFilter = (/**
 * @return {?}
 */
function () { return true; });
var Éµ0 = alwaysTrueInputFilter;
/**
 *  This directive allows the user to enter dates, using the keyboard, into an input box and
 *  angular will then store a date value in the model.
 *
 *  The input format(s), display format, and model format are independent and fully customizable.
 * @template D
 */
var DlDateTimeInputDirective = /** @class */ (function () {
    /**
     * Constructs a new instance of this directive.
     * @param _renderer
     *  reference to the renderer.
     * @param _elementRef
     *  reference to this element.
     * @param _dateAdapter
     *  date adapter for the date type in the model.
     * @param _displayFormat
     *  from `DL_DATE_TIME_DISPLAY_FORMAT`, which defines the format to use for a valid date/time value.
     * @param _inputFormats
     *  from `DL_DATE_TIME_INPUT_FORMATS`, which defines the input formats that allowed as valid date/time values.
     *  NB: moment is always in strict parse mode for this directive.
     */
    function DlDateTimeInputDirective(_renderer, _elementRef, _dateAdapter, _displayFormat, _inputFormats) {
        var _this = this;
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._dateAdapter = _dateAdapter;
        this._displayFormat = _displayFormat;
        this._inputFormats = _inputFormats;
        /* tslint:disable:member-ordering */
        this._filterValidator = (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            return (_this._inputFilter || alwaysTrueInputFilter)(_this._value) ?
                null : { 'dlDateTimeInputFilter': { 'value': control.value } };
        });
        this._inputFilter = alwaysTrueInputFilter;
        this._isValid = true;
        this._parseValidator = (/**
         * @return {?}
         */
        function () {
            return _this._isValid ?
                null : { 'dlDateTimeInputParse': { 'text': _this._elementRef.nativeElement.value } };
        });
        this._changed = [];
        this._touched = [];
        this._validator = Validators.compose([this._parseValidator, this._filterValidator]);
        this._validatorOnChange = (/**
         * @return {?}
         */
        function () { });
        this._value = undefined;
        /**
         * Emits when a `change` event when date/time is selected or
         * the value of the date/time picker changes.
         *
         */
        this.dateChange = new EventEmitter();
    }
    Object.defineProperty(DlDateTimeInputDirective.prototype, "dlDateTimeInputFilter", {
        /**
         * Set a function used to determine whether or not the `value` entered by the user is allowed.
         * @param inputFilterFunction
         *   a function that returns `true` if the `value` entered by the user is allowed, otherwise `false`.
         */
        set: /**
         * Set a function used to determine whether or not the `value` entered by the user is allowed.
         * @param {?} inputFilterFunction
         *   a function that returns `true` if the `value` entered by the user is allowed, otherwise `false`.
         * @return {?}
         */
        function (inputFilterFunction) {
            this._inputFilter = inputFilterFunction;
            this._validatorOnChange();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DlDateTimeInputDirective.prototype, "value", {
        /* tslint:enable:member-ordering */
        /**
         * Returns `D` value of the date/time input or `undefined` | `null` if no value is set.
         **/
        get: /* tslint:enable:member-ordering */
        /**
         * Returns `D` value of the date/time input or `undefined` | `null` if no value is set.
         *
         * @return {?}
         */
        function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Emit a `change` event when the value of the input changes.
     */
    /**
     * Emit a `change` event when the value of the input changes.
     * @return {?}
     */
    DlDateTimeInputDirective.prototype._onChange = /**
     * Emit a `change` event when the value of the input changes.
     * @return {?}
     */
    function () {
        this.dateChange.emit(new DlDateTimeInputChange(this._value));
    };
    /**
     * Format the input text using {@link DL_DATE_TIME_DISPLAY_FORMAT} and mark the control as touched.
     */
    /**
     * Format the input text using {\@link DL_DATE_TIME_DISPLAY_FORMAT} and mark the control as touched.
     * @return {?}
     */
    DlDateTimeInputDirective.prototype._onBlur = /**
     * Format the input text using {\@link DL_DATE_TIME_DISPLAY_FORMAT} and mark the control as touched.
     * @return {?}
     */
    function () {
        if (this._value) {
            this.writeValue(this._value);
        }
        this._touched.forEach((/**
         * @param {?} onTouched
         * @return {?}
         */
        function (onTouched) { return onTouched(); }));
    };
    /**
     * Parse the user input into a possibly valid date.
     * The model value is not set if the input is NOT one of the {@link DL_DATE_TIME_INPUT_FORMATS}.
     * @param value
     *   Value of the input control.
     */
    /**
     * Parse the user input into a possibly valid date.
     * The model value is not set if the input is NOT one of the {\@link DL_DATE_TIME_INPUT_FORMATS}.
     * @param {?} value
     *   Value of the input control.
     * @return {?}
     */
    DlDateTimeInputDirective.prototype._onInput = /**
     * Parse the user input into a possibly valid date.
     * The model value is not set if the input is NOT one of the {\@link DL_DATE_TIME_INPUT_FORMATS}.
     * @param {?} value
     *   Value of the input control.
     * @return {?}
     */
    function (value) {
        var _this = this;
        /** @type {?} */
        var testDate = value === null || value === undefined || value === ''
            ? undefined
            : moment(value, this._inputFormats, true);
        this._isValid = testDate && testDate.isValid();
        this._value = this._isValid ? this._dateAdapter.fromMilliseconds(testDate.valueOf()) : undefined;
        this._changed.forEach((/**
         * @param {?} onChanged
         * @return {?}
         */
        function (onChanged) { return onChanged(_this._value); }));
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} onChange
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.registerOnChange = /**
     * \@internal
     * @param {?} onChange
     * @return {?}
     */
    function (onChange) {
        this._changed.push(onChange);
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} onTouched
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.registerOnTouched = /**
     * \@internal
     * @param {?} onTouched
     * @return {?}
     */
    function (onTouched) {
        this._touched.push(onTouched);
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} validatorOnChange
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.registerOnValidatorChange = /**
     * \@internal
     * @param {?} validatorOnChange
     * @return {?}
     */
    function (validatorOnChange) {
        this._validatorOnChange = validatorOnChange;
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} isDisabled
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.setDisabledState = /**
     * \@internal
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} control
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.validate = /**
     * \@internal
     * @param {?} control
     * @return {?}
     */
    function (control) {
        return this._validator(control);
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} value
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.writeValue = /**
     * \@internal
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var normalizedValue = value === null || value === undefined
            ? ''
            : moment(value).format(this._displayFormat);
        this._renderer.setProperty(this._elementRef.nativeElement, 'value', normalizedValue);
    };
    DlDateTimeInputDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'input[dlDateTimeInput]',
                    providers: [
                        { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return DlDateTimeInputDirective; })), multi: true },
                        { provide: NG_VALIDATORS, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return DlDateTimeInputDirective; })), multi: true }
                    ]
                },] }
    ];
    /** @nocollapse */
    DlDateTimeInputDirective.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef },
        { type: DlDateAdapter },
        { type: String, decorators: [{ type: Inject, args: [DL_DATE_TIME_DISPLAY_FORMAT,] }] },
        { type: Array, decorators: [{ type: Inject, args: [DL_DATE_TIME_INPUT_FORMATS,] }] }
    ]; };
    DlDateTimeInputDirective.propDecorators = {
        dateChange: [{ type: Output }],
        dlDateTimeInputFilter: [{ type: Input }],
        _onChange: [{ type: HostListener, args: ['change',] }],
        _onBlur: [{ type: HostListener, args: ['blur',] }],
        _onInput: [{ type: HostListener, args: ['input', ['$event.target.value'],] }]
    };
    return DlDateTimeInputDirective;
}());
export { DlDateTimeInputDirective };
if (false) {
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._filterValidator;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._inputFilter;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._isValid;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._parseValidator;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._changed;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._touched;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._validator;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._validatorOnChange;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._value;
    /**
     * Emits when a `change` event when date/time is selected or
     * the value of the date/time picker changes.
     *
     * @type {?}
     */
    DlDateTimeInputDirective.prototype.dateChange;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._dateAdapter;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._displayFormat;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._inputFormats;
}
export { Éµ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGwtZGF0ZS10aW1lLWlucHV0LmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLyIsInNvdXJjZXMiOlsiZGwtZGF0ZS10aW1lLWlucHV0L2RsLWRhdGUtdGltZS1pbnB1dC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUM5SCxPQUFPLEVBR0wsYUFBYSxFQUNiLGlCQUFpQixFQUlqQixVQUFVLEdBQ1gsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEtBQUssT0FBTyxNQUFNLFFBQVEsQ0FBQztBQUNsQyxPQUFPLEVBQUMsMkJBQTJCLEVBQUUsMEJBQTBCLEVBQUUsYUFBYSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBQy9GLE9BQU8sRUFBQyxxQkFBcUIsRUFBQyxNQUFNLDZCQUE2QixDQUFDOzs7OztJQUs1RCxNQUFNLEdBQUcsT0FBTzs7Ozs7SUFLaEIscUJBQXFCOzs7QUFBNEIsY0FBTSxPQUFBLElBQUksRUFBSixDQUFJLENBQUE7Ozs7Ozs7OztBQVFqRTtJQWlDRTs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0gsa0NBQ1UsU0FBb0IsRUFDcEIsV0FBdUIsRUFDdkIsWUFBOEIsRUFDZ0IsY0FBc0IsRUFDdkIsYUFBdUI7UUFMOUUsaUJBTUk7UUFMTSxjQUFTLEdBQVQsU0FBUyxDQUFXO1FBQ3BCLGdCQUFXLEdBQVgsV0FBVyxDQUFZO1FBQ3ZCLGlCQUFZLEdBQVosWUFBWSxDQUFrQjtRQUNnQixtQkFBYyxHQUFkLGNBQWMsQ0FBUTtRQUN2QixrQkFBYSxHQUFiLGFBQWEsQ0FBVTs7UUExQ3RFLHFCQUFnQjs7OztRQUFnQixVQUFDLE9BQXdCO1lBQy9E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SkYsU0FBUyxTQUFDO29CQUNULFFBQVEsRUFBRSx3QkFBd0I7b0JBQ2xDLFNBQVMsRUFBRTt3QkFDVCxFQUFDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxXQUFXLEVBQUUsVUFBVTs7OzRCQUFDLGNBQU0sT0FBQSx3QkFBd0IsRUFBeEIsQ0FBd0IsRUFBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUM7d0JBQ2xHLEVBQUMsT0FBTyxFQUFFLGFBQWEsRUFBRSxXQUFXLEVBQUUsVUFBVTs7OzRCQUFDLGNBQU0sT0FBQSx3QkFBd0IsRUFBeEIsQ0FBd0IsRUFBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUM7cUJBQy9GO2lCQUNGOzs7O2dCQXJDNkYsU0FBUztnQkFBcEYsVUFBVTtnQkFZb0MsYUFBYTs2Q0FzRXpFLE1BQU0sU0FBQywyQkFBMkI7NENBQ2xDLE1BQU0sU0FBQywwQkFBMEI7Ozs2QkF0Qm5DLE1BQU07d0NBOEJOLEtBQUs7NEJBa0JMLFlBQVksU0FBQyxRQUFROzBCQU9yQixZQUFZLFNBQUMsTUFBTTsyQkFhbkIsWUFBWSxTQUFDLE9BQU8sRUFBRSxDQUFDLHFCQUFxQixDQUFDOztJQXNEaEQsK0JBQUM7Q0FBQSxBQXhKRCxJQXdKQztTQWpKWSx3QkFBd0I7Ozs7OztJQUduQyxvREFHQzs7Ozs7SUFDRCxnREFBNkU7Ozs7O0lBQzdFLDRDQUF3Qjs7Ozs7SUFDeEIsbURBR0M7Ozs7O0lBQ0QsNENBQThDOzs7OztJQUM5Qyw0Q0FBc0M7Ozs7O0lBQ3RDLDhDQUF1Rjs7Ozs7SUFDdkYsc0RBQWtEOzs7OztJQUNsRCwwQ0FBMEM7Ozs7Ozs7SUFNMUMsOENBQ21FOzs7OztJQWlCakUsNkNBQTRCOzs7OztJQUM1QiwrQ0FBK0I7Ozs7O0lBQy9CLGdEQUFzQzs7Ozs7SUFDdEMsa0RBQTRFOzs7OztJQUM1RSxpREFBNEUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0RpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBmb3J3YXJkUmVmLCBIb3N0TGlzdGVuZXIsIEluamVjdCwgSW5wdXQsIE91dHB1dCwgUmVuZGVyZXIyfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIEFic3RyYWN0Q29udHJvbCxcbiAgQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gIE5HX1ZBTElEQVRPUlMsXG4gIE5HX1ZBTFVFX0FDQ0VTU09SLFxuICBWYWxpZGF0aW9uRXJyb3JzLFxuICBWYWxpZGF0b3IsXG4gIFZhbGlkYXRvckZuLFxuICBWYWxpZGF0b3JzLFxufSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgKiBhcyBfbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQge0RMX0RBVEVfVElNRV9ESVNQTEFZX0ZPUk1BVCwgRExfREFURV9USU1FX0lOUFVUX0ZPUk1BVFMsIERsRGF0ZUFkYXB0ZXJ9IGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0IHtEbERhdGVUaW1lSW5wdXRDaGFuZ2V9IGZyb20gJy4vZGwtZGF0ZS10aW1lLWlucHV0LWNoYW5nZSc7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IG1vbWVudCA9IF9tb21lbnQ7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IGFsd2F5c1RydWVJbnB1dEZpbHRlcjogKHZhbHVlOiBhbnkpID0+IGJvb2xlYW4gPSAoKSA9PiB0cnVlO1xuXG4vKipcbiAqICBUaGlzIGRpcmVjdGl2ZSBhbGxvd3MgdGhlIHVzZXIgdG8gZW50ZXIgZGF0ZXMsIHVzaW5nIHRoZSBrZXlib2FyZCwgaW50byBhbiBpbnB1dCBib3ggYW5kXG4gKiAgYW5ndWxhciB3aWxsIHRoZW4gc3RvcmUgYSBkYXRlIHZhbHVlIGluIHRoZSBtb2RlbC5cbiAqXG4gKiAgVGhlIGlucHV0IGZvcm1hdChzKSwgZGlzcGxheSBmb3JtYXQsIGFuZCBtb2RlbCBmb3JtYXQgYXJlIGluZGVwZW5kZW50IGFuZCBmdWxseSBjdXN0b21pemFibGUuXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ2lucHV0W2RsRGF0ZVRpbWVJbnB1dF0nLFxuICBwcm92aWRlcnM6IFtcbiAgICB7cHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERsRGF0ZVRpbWVJbnB1dERpcmVjdGl2ZSksIG11bHRpOiB0cnVlfSxcbiAgICB7cHJvdmlkZTogTkdfVkFMSURBVE9SUywgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGxEYXRlVGltZUlucHV0RGlyZWN0aXZlKSwgbXVsdGk6IHRydWV9XG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgRGxEYXRlVGltZUlucHV0RGlyZWN0aXZlPEQ+IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIFZhbGlkYXRvciB7XG5cbiAgLyogdHNsaW50OmRpc2FibGU6bWVtYmVyLW9yZGVyaW5nICovXG4gIHByaXZhdGUgX2ZpbHRlclZhbGlkYXRvcjogVmFsaWRhdG9yRm4gPSAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xuICAgIHJldHVybiAodGhpcy5faW5wdXRGaWx0ZXIgfHwgYWx3YXlzVHJ1ZUlucHV0RmlsdGVyKSh0aGlzLl92YWx1ZSkgP1xuICAgICAgbnVsbCA6IHsnZGxEYXRlVGltZUlucHV0RmlsdGVyJzogeyd2YWx1ZSc6IGNvbnRyb2wudmFsdWV9fTtcbiAgfVxuICBwcml2YXRlIF9pbnB1dEZpbHRlcjogKHZhbHVlOiAoRCB8IG51bGwpKSA9PiBib29sZWFuID0gYWx3YXlzVHJ1ZUlucHV0RmlsdGVyO1xuICBwcml2YXRlIF9pc1ZhbGlkID0gdHJ1ZTtcbiAgcHJpdmF0ZSBfcGFyc2VWYWxpZGF0b3I6IFZhbGlkYXRvckZuID0gKCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICByZXR1cm4gdGhpcy5faXNWYWxpZCA/XG4gICAgICBudWxsIDogeydkbERhdGVUaW1lSW5wdXRQYXJzZSc6IHsndGV4dCc6IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZX19O1xuICB9XG4gIHByaXZhdGUgX2NoYW5nZWQ6ICgodmFsdWU6IEQpID0+IHZvaWQpW10gPSBbXTtcbiAgcHJpdmF0ZSBfdG91Y2hlZDogKCgpID0+IHZvaWQpW10gPSBbXTtcbiAgcHJpdmF0ZSBfdmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlKFt0aGlzLl9wYXJzZVZhbGlkYXRvciwgdGhpcy5fZmlsdGVyVmFsaWRhdG9yXSk7XG4gIHByaXZhdGUgX3ZhbGlkYXRvck9uQ2hhbmdlOiAoKSA9PiB2b2lkID0gKCkgPT4ge307XG4gIHByaXZhdGUgX3ZhbHVlOiBEIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIGEgYGNoYW5nZWAgZXZlbnQgd2hlbiBkYXRlL3RpbWUgaXMgc2VsZWN0ZWQgb3JcbiAgICogdGhlIHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyIGNoYW5nZXMuXG4gICAqKi9cbiAgQE91dHB1dCgpXG4gIHJlYWRvbmx5IGRhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPERsRGF0ZVRpbWVJbnB1dENoYW5nZTxEPj4oKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIGRpcmVjdGl2ZS5cbiAgICogQHBhcmFtIF9yZW5kZXJlclxuICAgKiAgcmVmZXJlbmNlIHRvIHRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIF9lbGVtZW50UmVmXG4gICAqICByZWZlcmVuY2UgdG8gdGhpcyBlbGVtZW50LlxuICAgKiBAcGFyYW0gX2RhdGVBZGFwdGVyXG4gICAqICBkYXRlIGFkYXB0ZXIgZm9yIHRoZSBkYXRlIHR5cGUgaW4gdGhlIG1vZGVsLlxuICAgKiBAcGFyYW0gX2Rpc3BsYXlGb3JtYXRcbiAgICogIGZyb20gYERMX0RBVEVfVElNRV9ESVNQTEFZX0ZPUk1BVGAsIHdoaWNoIGRlZmluZXMgdGhlIGZvcm1hdCB0byB1c2UgZm9yIGEgdmFsaWQgZGF0ZS90aW1lIHZhbHVlLlxuICAgKiBAcGFyYW0gX2lucHV0Rm9ybWF0c1xuICAgKiAgZnJvbSBgRExfREFURV9USU1FX0lOUFVUX0ZPUk1BVFNgLCB3aGljaCBkZWZpbmVzIHRoZSBpbnB1dCBmb3JtYXRzIHRoYXQgYWxsb3dlZCBhcyB2YWxpZCBkYXRlL3RpbWUgdmFsdWVzLlxuICAgKiAgTkI6IG1vbWVudCBpcyBhbHdheXMgaW4gc3RyaWN0IHBhcnNlIG1vZGUgZm9yIHRoaXMgZGlyZWN0aXZlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgX2RhdGVBZGFwdGVyOiBEbERhdGVBZGFwdGVyPEQ+LFxuICAgIEBJbmplY3QoRExfREFURV9USU1FX0RJU1BMQVlfRk9STUFUKSBwcml2YXRlIHJlYWRvbmx5IF9kaXNwbGF5Rm9ybWF0OiBzdHJpbmcsXG4gICAgQEluamVjdChETF9EQVRFX1RJTUVfSU5QVVRfRk9STUFUUykgcHJpdmF0ZSByZWFkb25seSBfaW5wdXRGb3JtYXRzOiBzdHJpbmdbXVxuICApIHt9XG5cbiAgLyoqXG4gICAqIFNldCBhIGZ1bmN0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRoZSBgdmFsdWVgIGVudGVyZWQgYnkgdGhlIHVzZXIgaXMgYWxsb3dlZC5cbiAgICogQHBhcmFtIGlucHV0RmlsdGVyRnVuY3Rpb25cbiAgICogICBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgZW50ZXJlZCBieSB0aGUgdXNlciBpcyBhbGxvd2VkLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCBkbERhdGVUaW1lSW5wdXRGaWx0ZXIoaW5wdXRGaWx0ZXJGdW5jdGlvbjogKHZhbHVlOiBEIHwgbnVsbCkgPT4gYm9vbGVhbikge1xuICAgIHRoaXMuX2lucHV0RmlsdGVyID0gaW5wdXRGaWx0ZXJGdW5jdGlvbjtcbiAgICB0aGlzLl92YWxpZGF0b3JPbkNoYW5nZSgpO1xuICB9XG5cbiAgLyogdHNsaW50OmVuYWJsZTptZW1iZXItb3JkZXJpbmcgKi9cblxuICAvKipcbiAgICogUmV0dXJucyBgRGAgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBpbnB1dCBvciBgdW5kZWZpbmVkYCB8IGBudWxsYCBpZiBubyB2YWx1ZSBpcyBzZXQuXG4gICAqKi9cbiAgZ2V0IHZhbHVlKCk6IEQge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGEgYGNoYW5nZWAgZXZlbnQgd2hlbiB0aGUgdmFsdWUgb2YgdGhlIGlucHV0IGNoYW5nZXMuXG4gICAqL1xuICBASG9zdExpc3RlbmVyKCdjaGFuZ2UnKSBfb25DaGFuZ2UoKSB7XG4gICAgdGhpcy5kYXRlQ2hhbmdlLmVtaXQobmV3IERsRGF0ZVRpbWVJbnB1dENoYW5nZSh0aGlzLl92YWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1hdCB0aGUgaW5wdXQgdGV4dCB1c2luZyB7QGxpbmsgRExfREFURV9USU1FX0RJU1BMQVlfRk9STUFUfSBhbmQgbWFyayB0aGUgY29udHJvbCBhcyB0b3VjaGVkLlxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcignYmx1cicpIF9vbkJsdXIoKSB7XG4gICAgaWYgKHRoaXMuX3ZhbHVlKSB7XG4gICAgICB0aGlzLndyaXRlVmFsdWUodGhpcy5fdmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLl90b3VjaGVkLmZvckVhY2gob25Ub3VjaGVkID0+IG9uVG91Y2hlZCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgdXNlciBpbnB1dCBpbnRvIGEgcG9zc2libHkgdmFsaWQgZGF0ZS5cbiAgICogVGhlIG1vZGVsIHZhbHVlIGlzIG5vdCBzZXQgaWYgdGhlIGlucHV0IGlzIE5PVCBvbmUgb2YgdGhlIHtAbGluayBETF9EQVRFX1RJTUVfSU5QVVRfRk9STUFUU30uXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiAgIFZhbHVlIG9mIHRoZSBpbnB1dCBjb250cm9sLlxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcignaW5wdXQnLCBbJyRldmVudC50YXJnZXQudmFsdWUnXSkgX29uSW5wdXQodmFsdWU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBjb25zdCB0ZXN0RGF0ZSA9IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09ICcnXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiBtb21lbnQodmFsdWUsIHRoaXMuX2lucHV0Rm9ybWF0cywgdHJ1ZSk7XG5cbiAgICB0aGlzLl9pc1ZhbGlkID0gdGVzdERhdGUgJiYgdGVzdERhdGUuaXNWYWxpZCgpO1xuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5faXNWYWxpZCA/IHRoaXMuX2RhdGVBZGFwdGVyLmZyb21NaWxsaXNlY29uZHModGVzdERhdGUudmFsdWVPZigpKSA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jaGFuZ2VkLmZvckVhY2gob25DaGFuZ2VkID0+IG9uQ2hhbmdlZCh0aGlzLl92YWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVnaXN0ZXJPbkNoYW5nZShvbkNoYW5nZTogKHZhbHVlOiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLl9jaGFuZ2VkLnB1c2gob25DaGFuZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVnaXN0ZXJPblRvdWNoZWQob25Ub3VjaGVkOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fdG91Y2hlZC5wdXNoKG9uVG91Y2hlZCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKHZhbGlkYXRvck9uQ2hhbmdlOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UgPSB2YWxpZGF0b3JPbkNoYW5nZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICB2YWxpZGF0ZShjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvcihjb250cm9sKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHdyaXRlVmFsdWUodmFsdWU6IEQpOiB2b2lkIHtcbiAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICcnXG4gICAgICA6IG1vbWVudCh2YWx1ZSkuZm9ybWF0KHRoaXMuX2Rpc3BsYXlGb3JtYXQpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgbm9ybWFsaXplZFZhbHVlKTtcbiAgfVxufVxuIl19